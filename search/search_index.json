{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTP3 HTTP3 is a next-generation HTTP client for Python 3. Warning This project should be considered as an \"alpha\" release. It is substantially API complete, but there are still some areas that need more work. Let's get started... >>> import http3 >>> r = http3 . get ( 'https://www.example.org/' ) >>> r . status_code < StatusCode . OK : 200 > >>> r . protocol 'HTTP/2' >>> r . headers [ 'content-type' ] 'text/html; charset=UTF-8' >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Features HTTP3 builds on the well-established usability of requests , and gives you: A requests-compatible API. HTTP/2 and HTTP/1.1 support. Support for issuing HTTP requests in parallel. Standard synchronous interface, but with async / await support if you need it. Strict timeouts everywhere. Fully type annotated. 100% test coverage. Plus all the standard features of requests ... International Domains and URLs Keep-Alive & Connection Pooling Sessions with Cookie Persistence Browser-style SSL Verification Basic/Digest Authentication Digest is still TODO Elegant Key/Value Cookies Automatic Decompression Automatic Content Decoding Unicode Response Bodies Multipart File Uploads TODO HTTP(S) Proxy Support TODO Connection Timeouts Streaming Downloads .netrc Support TODO Chunked Requests Documentation For a run-through of all the basics, head over to the QuickStart . For more advanced topics, see the Parallel Requests or Async Client documentation. The Developer Interface provides a comprehensive API reference. Dependencies The HTTP3 project relies on these excellent libraries: h2 - HTTP/2 support. h11 - HTTP/1.1 support. certifi - SSL certificates. chardet - Fallback auto-detection for response encoding. idna - Internationalized domain name support. rfc3986 - URL parsing & normalization. brotlipy - Decoding for \"brotli\" compressed responses. (Optional) A huge amount of credit is due to requests for the API layout that much of this work follows, as well as to urllib3 for plenty of design inspiration around the lower level networking details. Installation Install with pip: $ pip install http3 HTTP3 requires Python 3.6+","title":"Introduction"},{"location":"#features","text":"HTTP3 builds on the well-established usability of requests , and gives you: A requests-compatible API. HTTP/2 and HTTP/1.1 support. Support for issuing HTTP requests in parallel. Standard synchronous interface, but with async / await support if you need it. Strict timeouts everywhere. Fully type annotated. 100% test coverage. Plus all the standard features of requests ... International Domains and URLs Keep-Alive & Connection Pooling Sessions with Cookie Persistence Browser-style SSL Verification Basic/Digest Authentication Digest is still TODO Elegant Key/Value Cookies Automatic Decompression Automatic Content Decoding Unicode Response Bodies Multipart File Uploads TODO HTTP(S) Proxy Support TODO Connection Timeouts Streaming Downloads .netrc Support TODO Chunked Requests","title":"Features"},{"location":"#documentation","text":"For a run-through of all the basics, head over to the QuickStart . For more advanced topics, see the Parallel Requests or Async Client documentation. The Developer Interface provides a comprehensive API reference.","title":"Documentation"},{"location":"#dependencies","text":"The HTTP3 project relies on these excellent libraries: h2 - HTTP/2 support. h11 - HTTP/1.1 support. certifi - SSL certificates. chardet - Fallback auto-detection for response encoding. idna - Internationalized domain name support. rfc3986 - URL parsing & normalization. brotlipy - Decoding for \"brotli\" compressed responses. (Optional) A huge amount of credit is due to requests for the API layout that much of this work follows, as well as to urllib3 for plenty of design inspiration around the lower level networking details.","title":"Dependencies"},{"location":"#installation","text":"Install with pip: $ pip install http3 HTTP3 requires Python 3.6+","title":"Installation"},{"location":"api/","text":"Developer Interface Main Interface get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) Client An HTTP client, with connection pooling, redirects, cookie persistence, etc. >>> client = http3 . Client () >>> response = client . get ( 'https://example.org' ) def __init__([auth], [cookies], [verify], [cert], [timeout], [pool_limits], [max_redirects], [dispatch]) def .get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .send(request, [stream], [allow_redirects], [verify], [cert], [timeout]) def .close() Response An HTTP response. def __init__(...) .status_code - int (Typically a StatusCode IntEnum.) .reason_phrase - str .protocol - \"HTTP/2\" or \"HTTP/1.1\" .url - URL .headers - Headers .content - bytes .text - str .encoding - str .is_redirect - bool .request - Request .cookies - Cookies .history - List[Response] def .raise_for_status() - None def .json() - Any def .read() - bytes def .stream() - bytes iterator def .raw() - bytes iterator def .close() - None def .next() - Response Request An HTTP request. Can be constructed explicitly for more control over exactly what gets sent over the wire. >>> request = http3 . Request ( \"GET\" , \"https://example.org\" , headers = { 'host' : 'example.org' }) >>> response = client . send ( request ) def __init__(method, url, [params], [data], [json], [headers], [cookies]) .method - str .url - URL .content - byte or byte async iterator .headers - Headers .cookies - Cookies URL A normalized, IDNA supporting URL. >>> url = URL ( \"https://example.org/\" ) >>> url . host 'example.org' def __init__(url, allow_relative=False, params=None) .scheme - str .authority - str .host - str .port - int .path - str .query - str .full_path - str .fragment - str .is_ssl - bool .origin - Origin .is_absolute_url - bool .is_relative_url - bool def .copy_with([scheme], [authority], [path], [query], [fragment]) - URL def .resolve_with(url) - URL Origin A normalized, IDNA supporting set of scheme/host/port info. >>> Origin ( 'https://example.org' ) == Origin ( 'HTTPS://EXAMPLE.ORG:443' ) True def __init__(url) .is_ssl - bool .host - str .port - int Headers A case-insensitive multi-dict. >>> headers = Headers ({ 'Content-Type' : 'application/json' }) >>> headers [ 'content-type' ] 'application/json' def __init__(self, headers) Cookies A dict-like cookie store. >>> cookies = Cookies () >>> cookies . set ( \"name\" , \"value\" , domain = \"example.org\" ) def __init__(cookies: [dict, Cookies, CookieJar]) .jar - CookieJar def extract_cookies(response) def set_cookie_header(request) def set(name, value, [domain], [path]) def get(name, [domain], [path]) def delete(name, [domain], [path]) def clear([domain], [path]) Standard mutable mapping interface","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#main-interface","text":"get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])","title":"Main Interface"},{"location":"api/#client","text":"An HTTP client, with connection pooling, redirects, cookie persistence, etc. >>> client = http3 . Client () >>> response = client . get ( 'https://example.org' ) def __init__([auth], [cookies], [verify], [cert], [timeout], [pool_limits], [max_redirects], [dispatch]) def .get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout]) def .send(request, [stream], [allow_redirects], [verify], [cert], [timeout]) def .close()","title":"Client"},{"location":"api/#response","text":"An HTTP response. def __init__(...) .status_code - int (Typically a StatusCode IntEnum.) .reason_phrase - str .protocol - \"HTTP/2\" or \"HTTP/1.1\" .url - URL .headers - Headers .content - bytes .text - str .encoding - str .is_redirect - bool .request - Request .cookies - Cookies .history - List[Response] def .raise_for_status() - None def .json() - Any def .read() - bytes def .stream() - bytes iterator def .raw() - bytes iterator def .close() - None def .next() - Response","title":"Response"},{"location":"api/#request","text":"An HTTP request. Can be constructed explicitly for more control over exactly what gets sent over the wire. >>> request = http3 . Request ( \"GET\" , \"https://example.org\" , headers = { 'host' : 'example.org' }) >>> response = client . send ( request ) def __init__(method, url, [params], [data], [json], [headers], [cookies]) .method - str .url - URL .content - byte or byte async iterator .headers - Headers .cookies - Cookies","title":"Request"},{"location":"api/#url","text":"A normalized, IDNA supporting URL. >>> url = URL ( \"https://example.org/\" ) >>> url . host 'example.org' def __init__(url, allow_relative=False, params=None) .scheme - str .authority - str .host - str .port - int .path - str .query - str .full_path - str .fragment - str .is_ssl - bool .origin - Origin .is_absolute_url - bool .is_relative_url - bool def .copy_with([scheme], [authority], [path], [query], [fragment]) - URL def .resolve_with(url) - URL","title":"URL"},{"location":"api/#origin","text":"A normalized, IDNA supporting set of scheme/host/port info. >>> Origin ( 'https://example.org' ) == Origin ( 'HTTPS://EXAMPLE.ORG:443' ) True def __init__(url) .is_ssl - bool .host - str .port - int","title":"Origin"},{"location":"api/#headers","text":"A case-insensitive multi-dict. >>> headers = Headers ({ 'Content-Type' : 'application/json' }) >>> headers [ 'content-type' ] 'application/json' def __init__(self, headers)","title":"Headers"},{"location":"api/#cookies","text":"A dict-like cookie store. >>> cookies = Cookies () >>> cookies . set ( \"name\" , \"value\" , domain = \"example.org\" ) def __init__(cookies: [dict, Cookies, CookieJar]) .jar - CookieJar def extract_cookies(response) def set_cookie_header(request) def set(name, value, [domain], [path]) def get(name, [domain], [path]) def delete(name, [domain], [path]) def clear([domain], [path]) Standard mutable mapping interface","title":"Cookies"},{"location":"async/","text":"Async Client HTTP3 offers a standard synchronous API by default, but also gives you the option of an async client if you need it. Async is a concurrency model that is far more efficient than multi-threading, and can provide significant performance benefits and enable the use of long-lived network connections such as WebSockets. If you're working with an async web framework such as Sanic, Starlette, FastAPI, Responder or Bocadillo, then you'll also want to use an async client for sending outgoing HTTP requests. Making Async requests To make asynchronous requests, you'll need an AsyncClient . >>> client = http3 . AsyncClient () >>> r = await client . get ( 'https://www.example.com/' ) API Differences If you're using streaming responses then there are a few bits of API that use async methods: >>> client = http3 . AsyncClient () >>> r = await client . get ( 'https://www.example.com/' , stream = True ) >>> try : >>> async for chunk in r . stream (): >>> ... >>> finally : >>> await r . close () The async response methods are: .read() .stream() .raw() .close() If you're making parallel requests, then you'll also need to use an async API: >>> client = http3 . AsyncClient () >>> async with client . parallel () as parallel : >>> pending_one = parallel . get ( 'https://example.com/1' ) >>> pending_two = parallel . get ( 'https://example.com/2' ) >>> response_one = await pending_one . get_response () >>> response_two = await pending_two . get_response () The async parallel methods are: .parallel() Used as an \"async with\" context manager. .get_response() .next_response()","title":"Async Client"},{"location":"async/#async-client","text":"HTTP3 offers a standard synchronous API by default, but also gives you the option of an async client if you need it. Async is a concurrency model that is far more efficient than multi-threading, and can provide significant performance benefits and enable the use of long-lived network connections such as WebSockets. If you're working with an async web framework such as Sanic, Starlette, FastAPI, Responder or Bocadillo, then you'll also want to use an async client for sending outgoing HTTP requests.","title":"Async Client"},{"location":"async/#making-async-requests","text":"To make asynchronous requests, you'll need an AsyncClient . >>> client = http3 . AsyncClient () >>> r = await client . get ( 'https://www.example.com/' )","title":"Making Async requests"},{"location":"async/#api-differences","text":"If you're using streaming responses then there are a few bits of API that use async methods: >>> client = http3 . AsyncClient () >>> r = await client . get ( 'https://www.example.com/' , stream = True ) >>> try : >>> async for chunk in r . stream (): >>> ... >>> finally : >>> await r . close () The async response methods are: .read() .stream() .raw() .close() If you're making parallel requests, then you'll also need to use an async API: >>> client = http3 . AsyncClient () >>> async with client . parallel () as parallel : >>> pending_one = parallel . get ( 'https://example.com/1' ) >>> pending_two = parallel . get ( 'https://example.com/2' ) >>> response_one = await pending_one . get_response () >>> response_two = await pending_two . get_response () The async parallel methods are: .parallel() Used as an \"async with\" context manager. .get_response() .next_response()","title":"API Differences"},{"location":"compatibility/","text":"Requests Compatibility Guide HTTP3 aims to be compatible with the requests API wherever possible. This documentation outlines places where the API differs... QuickStart Pretty much all the API mentioned in the requests QuickStart should be identical to the API in our own documentation. The following exceptions apply: Response.url - Returns a URL instance, rather than a string. Use str(response.url) if you need a string instance. Response.status_code - Returns an integer, which may be a StatusCode IntEnum. This has the same behaviour as any other integer, except that it provides more information in the instance representation. http3.codes - In our documentation we prefer the uppercased versions, such as codes.NOT_FOUND , but also provide lower-cased versions for API compatibility with requests . stream=True . - Streaming responses provide the .stream() and .raw() byte iterator interfaces, rather than the .iter_content() method and the .raw socket interface. Advanced Usage Warning TODO","title":"Requests Compatibility"},{"location":"compatibility/#requests-compatibility-guide","text":"HTTP3 aims to be compatible with the requests API wherever possible. This documentation outlines places where the API differs...","title":"Requests Compatibility Guide"},{"location":"compatibility/#quickstart","text":"Pretty much all the API mentioned in the requests QuickStart should be identical to the API in our own documentation. The following exceptions apply: Response.url - Returns a URL instance, rather than a string. Use str(response.url) if you need a string instance. Response.status_code - Returns an integer, which may be a StatusCode IntEnum. This has the same behaviour as any other integer, except that it provides more information in the instance representation. http3.codes - In our documentation we prefer the uppercased versions, such as codes.NOT_FOUND , but also provide lower-cased versions for API compatibility with requests . stream=True . - Streaming responses provide the .stream() and .raw() byte iterator interfaces, rather than the .iter_content() method and the .raw socket interface.","title":"QuickStart"},{"location":"compatibility/#advanced-usage","text":"Warning TODO","title":"Advanced Usage"},{"location":"parallel/","text":"Parallel Requests Warning This page documents some proposed functionality that is not yet released. See pull request #52 for the first-pass of an implementation. HTTP3 allows you to make HTTP requests in parallel in a highly efficient way, using async under the hood, while still presenting a standard threaded interface. This has the huge benefit of allowing you to efficiently make parallel HTTP requests without having to switch out to using async all the way through. Making Parallel Requests Let's make two outgoing HTTP requests in parallel: >>> with http3 . parallel () as parallel : >>> pending_one = parallel . get ( 'https://example.com/1' ) >>> pending_two = parallel . get ( 'https://example.com/2' ) >>> response_one = pending_one . get_response () >>> response_two = pending_two . get_response () If we're making lots of outgoing requests, we might not want to deal with the responses sequentially, but rather deal with each response that comes back as soon as it's available: >>> with http3 . parallel () as parallel : >>> for counter in range ( 1 , 10 ): >>> parallel . get ( f 'https://example.com/{counter}' ) >>> while parallel . has_pending_responses : >>> r = parallel . next_response () Exceptions and Cancellations The style of using parallel blocks ensures that you'll always have well defined exception and cancellation behaviours. Request exceptions are only ever raised when calling either get_response or next_response , and any pending requests are cancelled on exiting the block. Parallel requests with a Client You can also call parallel() from a client instance, which allows you to control the authentication or dispatch behaviour for all requests within the block. >>> client = http3 . Client () >>> with client . parallel () as parallel : >>> ... Async parallel requests If you're working within an async framework, then you'll want to use a fully async API for making requests. >>> client = http3 . AsyncClient () >>> async with client . parallel () as parallel : >>> pending_one = await parallel . get ( 'https://example.com/1' ) >>> pending_two = await parallel . get ( 'https://example.com/2' ) >>> response_one = await pending_one . get_response () >>> response_two = await pending_two . get_response () See the Async Client documentation for more details.","title":"Parallel Requests"},{"location":"parallel/#parallel-requests","text":"Warning This page documents some proposed functionality that is not yet released. See pull request #52 for the first-pass of an implementation. HTTP3 allows you to make HTTP requests in parallel in a highly efficient way, using async under the hood, while still presenting a standard threaded interface. This has the huge benefit of allowing you to efficiently make parallel HTTP requests without having to switch out to using async all the way through.","title":"Parallel Requests"},{"location":"parallel/#making-parallel-requests","text":"Let's make two outgoing HTTP requests in parallel: >>> with http3 . parallel () as parallel : >>> pending_one = parallel . get ( 'https://example.com/1' ) >>> pending_two = parallel . get ( 'https://example.com/2' ) >>> response_one = pending_one . get_response () >>> response_two = pending_two . get_response () If we're making lots of outgoing requests, we might not want to deal with the responses sequentially, but rather deal with each response that comes back as soon as it's available: >>> with http3 . parallel () as parallel : >>> for counter in range ( 1 , 10 ): >>> parallel . get ( f 'https://example.com/{counter}' ) >>> while parallel . has_pending_responses : >>> r = parallel . next_response ()","title":"Making Parallel Requests"},{"location":"parallel/#exceptions-and-cancellations","text":"The style of using parallel blocks ensures that you'll always have well defined exception and cancellation behaviours. Request exceptions are only ever raised when calling either get_response or next_response , and any pending requests are cancelled on exiting the block.","title":"Exceptions and Cancellations"},{"location":"parallel/#parallel-requests-with-a-client","text":"You can also call parallel() from a client instance, which allows you to control the authentication or dispatch behaviour for all requests within the block. >>> client = http3 . Client () >>> with client . parallel () as parallel : >>> ...","title":"Parallel requests with a Client"},{"location":"parallel/#async-parallel-requests","text":"If you're working within an async framework, then you'll want to use a fully async API for making requests. >>> client = http3 . AsyncClient () >>> async with client . parallel () as parallel : >>> pending_one = await parallel . get ( 'https://example.com/1' ) >>> pending_two = await parallel . get ( 'https://example.com/2' ) >>> response_one = await pending_one . get_response () >>> response_two = await pending_two . get_response () See the Async Client documentation for more details.","title":"Async parallel requests"},{"location":"quickstart/","text":"QuickStart Note This page closely follows the layout of the requests QuickStart documentation. The http3 library is designed to be API compatible with requests wherever possible. First start by importing HTTP3: >>> import http3 Now, let\u2019s try to get a webpage. >>> r = http3 . get ( 'https://httpbin.org/get' ) Similarly, to make an HTTP POST request: >>> r = http3 . post ( 'https://httpbin.org/post' , data = { 'key' : 'value' }) The PUT, DELETE, HEAD, and OPTIONS requests all follow the same style: >>> r = http3 . put ( 'https://httpbin.org/put' , data = { 'key' : 'value' }) >>> r = http3 . delete ( 'https://httpbin.org/delete' ) >>> r = http3 . head ( 'https://httpbin.org/get' ) >>> r = http3 . options ( 'https://httpbin.org/get' ) Passing Parameters in URLs To include URL query parameters in the request, use the params keyword: >>> params = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = http3 . get ( 'https://httpbin.org/get' , params = params ) To see how the values get encoding into the URL string, we can inspect the resulting URL that was used to make the request: >>> r . url URL ( 'https://httpbin.org/get?key2=value2&key1=value1' ) You can also pass a list of items as a value: >>> params = { 'key1' : 'value1' , 'key2' : [ 'value2' , 'value3' ]} >>> r = http3 . get ( 'https://httpbin.org/get' , params = params ) >>> r . url URL ( 'https://httpbin.org/get?key1=value1&key2=value2&key2=value3' ) Response Content HTTP3 will automatically handle decoding the response content into unicode text. >>> r = http3 . get ( 'https://www.example.org/' ) >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' You can inspect what encoding has been used to decode the response. >>> r . encoding 'UTF-8' If you need to override the standard behavior and explicitly set the encoding to use, then you can do that too. >>> r . encoding = 'ISO-8859-1' Binary Response Content The response content can also be accessed as bytes, for non-text responses: >>> r . content b '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Any gzip and deflate HTTP response encodings will automatically be decoded for you. If brotlipy is installed, then the brotli response encoding will also be supported. For example, to create an image from binary data returned by a request, you can use the following code: >>> from PIL import Image >>> from io import BytesIO >>> i = Image . open ( BytesIO ( r . content )) JSON Response Content Often Web API responses will be encoded as JSON. >>> r = http3 . get ( 'https://api.github.com/events' ) >>> r . json () [{ u 'repository' : { u 'open_issues' : 0 , u 'url' : 'https://github.com/...' ... }}] Custom Headers To include additional headers in the outgoing request, use the headers keyword argument: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> r = http3 . get ( url , headers = headers ) Sending Form Encoded Data Some types of HTTP requests, such as POST and PUT requests, can include data in the request body. One common way of including that is as form encoded data, which is used for HTML forms. >>> data = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = http3 . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key2\" : \"value2\" , \"key1\" : \"value1\" }, ... } Form encoded data can also include multiple values form a given key. >>> data = { 'key1' : [ 'value1' , 'value2' ]} >>> r = http3 . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key1\" : [ \"value1\" , \"value2\" ] }, ... } Sending JSON Encoded Data Form encoded data is okay if all you need is simple key-value data structure. For more complicated data structures you'll often want to use JSON encoding instead. >>> data = { 'integer' : 123 , 'boolean' : True , 'list' : [ 'a' , 'b' , 'c' ]} >>> r = http3 . post ( \"https://httpbin.org/post\" , json = data ) >>> print ( r . text ) { ... \"json\" : { \"boolean\" : true , \"integer\" : 123 , \"list\" : [ \"a\" , \"b\" , \"c\" ] }, ... } Sending Binary Request Data For other encodings you should use either a bytes type, or a generator that yields bytes . You'll probably also want to set a custom Content-Type header when uploading binary data. Response Status Codes We can inspect the HTTP status code of the response: >>> r = http3 . get ( 'https://httpbin.org/get' ) >>> r . status_code < StatusCode . OK : 200 > The status code is an integer enum, meaning that the Python representation gives use some descriptive information, but the value itself can be used as a regular integer. >>> r . status_code == 200 True HTTP3 also includes an easy shortcut for accessing status codes by their text phrase. >>> r . status_code == requests . codes . OK True We can raise an exception for any Client or Server error responses (4xx or 5xx status codes): >>> not_found = http3 . get ( 'https://httpbin.org/status/404' ) >>> not_found . status_code < StatusCode . NOT_FOUND : 404 > >>> not_found . raise_for_status () Traceback ( most recent call last ): File \"/Users/tomchristie/GitHub/encode/httpcore/http3/models.py\" , line 776 , in raise_for_status raise HttpError ( message ) http3 . exceptions . HttpError : 404 Not Found Any successful response codes will simply return None rather than raising an exception. >>> r . raise_for_status () Response Headers The response headers are available as a dictionary-like interface. >>> r . headers Headers ({ 'content-encoding' : 'gzip' , 'transfer-encoding' : 'chunked' , 'connection' : 'close' , 'server' : 'nginx/1.0.4' , 'x-runtime' : '148ms' , 'etag' : '\"e1ca502697e5c9317743dc078f67693f\"' , 'content-type' : 'application/json' }) The Headers data type is case-insensitive, so you can use any capitalization. >>> r . headers [ 'Content-Type' ] 'application/json' >>> r . headers . get ( 'content-type' ) 'application/json' Multiple values for a single response header are represented as a single comma separated value, as per RFC 7230 : A recipient MAY combine multiple header fields with the same field name into one \u201cfield-name: field-value\u201d pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma. Cookies Any cookies that are set on the response can be easily accessed: >>> r = http3 . get ( 'http://httpbin.org/cookies/set?chocolate=chip' , allow_redirects = False ) >>> r . cookies [ 'chocolate' ] 'chip' To include cookies in an outgoing request, use the cookies parameter: >>> cookies = { \"peanut\" : \"butter\" } >>> r = http3 . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'peanut' : 'butter' }} Cookies are returned in a Cookies instance, which is a dict-like data structure with additional API for accessing cookies by their domain or path. >>> cookies = http3 . Cookies () >>> cookies . set ( 'cookie_on_domain' , 'hello, there!' , domain = 'httpbin.org' ) >>> cookies . set ( 'cookie_off_domain' , 'nope.' , domain = 'example.org' ) >>> r = http3 . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'cookie_on_domain' : 'hello, there!' }} Redirection and History By default HTTP3 will follow redirects for anything except HEAD requests. The history property of the response can be used to inspect any followed redirects. It contains a list of all any redirect responses that were followed, in the order in which they were made. For example, GitHub redirects all HTTP requests to HTTPS. >>> r = http3 . get ( 'http://github.com/' ) >>> r . url URL ( 'https://github.com/' ) >>> r . status_code < StatusCode . OK : 200 > >>> r . history [ < Response [ 301 ] > ] You can modify the default redirection handling with the allow_redirects parameter: >>> r = http3 . get ( 'http://github.com/' , allow_redirects = False ) >>> r . status_code 301 >>> r . history [] If you\u2019re making a HEAD request, you can use this to enable redirection: >>> r = http3 . head ( 'http://github.com/' , allow_redirects = True ) >>> r . url 'https://github.com/' >>> r . history [ < Response [ 301 ] > ] Timeouts HTTP3 defaults to including reasonable timeouts for all network operations, meaning that if a connection is not properly established then it should always raise an error rather than hanging indefinitely. The default timeout for network inactivity is five seconds. You can modify the value to be more or less strict: >>> http3 . get ( 'https://github.com/' , timeout = 0.001 )","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"Note This page closely follows the layout of the requests QuickStart documentation. The http3 library is designed to be API compatible with requests wherever possible. First start by importing HTTP3: >>> import http3 Now, let\u2019s try to get a webpage. >>> r = http3 . get ( 'https://httpbin.org/get' ) Similarly, to make an HTTP POST request: >>> r = http3 . post ( 'https://httpbin.org/post' , data = { 'key' : 'value' }) The PUT, DELETE, HEAD, and OPTIONS requests all follow the same style: >>> r = http3 . put ( 'https://httpbin.org/put' , data = { 'key' : 'value' }) >>> r = http3 . delete ( 'https://httpbin.org/delete' ) >>> r = http3 . head ( 'https://httpbin.org/get' ) >>> r = http3 . options ( 'https://httpbin.org/get' )","title":"QuickStart"},{"location":"quickstart/#passing-parameters-in-urls","text":"To include URL query parameters in the request, use the params keyword: >>> params = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = http3 . get ( 'https://httpbin.org/get' , params = params ) To see how the values get encoding into the URL string, we can inspect the resulting URL that was used to make the request: >>> r . url URL ( 'https://httpbin.org/get?key2=value2&key1=value1' ) You can also pass a list of items as a value: >>> params = { 'key1' : 'value1' , 'key2' : [ 'value2' , 'value3' ]} >>> r = http3 . get ( 'https://httpbin.org/get' , params = params ) >>> r . url URL ( 'https://httpbin.org/get?key1=value1&key2=value2&key2=value3' )","title":"Passing Parameters in URLs"},{"location":"quickstart/#response-content","text":"HTTP3 will automatically handle decoding the response content into unicode text. >>> r = http3 . get ( 'https://www.example.org/' ) >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' You can inspect what encoding has been used to decode the response. >>> r . encoding 'UTF-8' If you need to override the standard behavior and explicitly set the encoding to use, then you can do that too. >>> r . encoding = 'ISO-8859-1'","title":"Response Content"},{"location":"quickstart/#binary-response-content","text":"The response content can also be accessed as bytes, for non-text responses: >>> r . content b '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Any gzip and deflate HTTP response encodings will automatically be decoded for you. If brotlipy is installed, then the brotli response encoding will also be supported. For example, to create an image from binary data returned by a request, you can use the following code: >>> from PIL import Image >>> from io import BytesIO >>> i = Image . open ( BytesIO ( r . content ))","title":"Binary Response Content"},{"location":"quickstart/#json-response-content","text":"Often Web API responses will be encoded as JSON. >>> r = http3 . get ( 'https://api.github.com/events' ) >>> r . json () [{ u 'repository' : { u 'open_issues' : 0 , u 'url' : 'https://github.com/...' ... }}]","title":"JSON Response Content"},{"location":"quickstart/#custom-headers","text":"To include additional headers in the outgoing request, use the headers keyword argument: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> r = http3 . get ( url , headers = headers )","title":"Custom Headers"},{"location":"quickstart/#sending-form-encoded-data","text":"Some types of HTTP requests, such as POST and PUT requests, can include data in the request body. One common way of including that is as form encoded data, which is used for HTML forms. >>> data = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = http3 . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key2\" : \"value2\" , \"key1\" : \"value1\" }, ... } Form encoded data can also include multiple values form a given key. >>> data = { 'key1' : [ 'value1' , 'value2' ]} >>> r = http3 . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key1\" : [ \"value1\" , \"value2\" ] }, ... }","title":"Sending Form Encoded Data"},{"location":"quickstart/#sending-json-encoded-data","text":"Form encoded data is okay if all you need is simple key-value data structure. For more complicated data structures you'll often want to use JSON encoding instead. >>> data = { 'integer' : 123 , 'boolean' : True , 'list' : [ 'a' , 'b' , 'c' ]} >>> r = http3 . post ( \"https://httpbin.org/post\" , json = data ) >>> print ( r . text ) { ... \"json\" : { \"boolean\" : true , \"integer\" : 123 , \"list\" : [ \"a\" , \"b\" , \"c\" ] }, ... }","title":"Sending JSON Encoded Data"},{"location":"quickstart/#sending-binary-request-data","text":"For other encodings you should use either a bytes type, or a generator that yields bytes . You'll probably also want to set a custom Content-Type header when uploading binary data.","title":"Sending Binary Request Data"},{"location":"quickstart/#response-status-codes","text":"We can inspect the HTTP status code of the response: >>> r = http3 . get ( 'https://httpbin.org/get' ) >>> r . status_code < StatusCode . OK : 200 > The status code is an integer enum, meaning that the Python representation gives use some descriptive information, but the value itself can be used as a regular integer. >>> r . status_code == 200 True HTTP3 also includes an easy shortcut for accessing status codes by their text phrase. >>> r . status_code == requests . codes . OK True We can raise an exception for any Client or Server error responses (4xx or 5xx status codes): >>> not_found = http3 . get ( 'https://httpbin.org/status/404' ) >>> not_found . status_code < StatusCode . NOT_FOUND : 404 > >>> not_found . raise_for_status () Traceback ( most recent call last ): File \"/Users/tomchristie/GitHub/encode/httpcore/http3/models.py\" , line 776 , in raise_for_status raise HttpError ( message ) http3 . exceptions . HttpError : 404 Not Found Any successful response codes will simply return None rather than raising an exception. >>> r . raise_for_status ()","title":"Response Status Codes"},{"location":"quickstart/#response-headers","text":"The response headers are available as a dictionary-like interface. >>> r . headers Headers ({ 'content-encoding' : 'gzip' , 'transfer-encoding' : 'chunked' , 'connection' : 'close' , 'server' : 'nginx/1.0.4' , 'x-runtime' : '148ms' , 'etag' : '\"e1ca502697e5c9317743dc078f67693f\"' , 'content-type' : 'application/json' }) The Headers data type is case-insensitive, so you can use any capitalization. >>> r . headers [ 'Content-Type' ] 'application/json' >>> r . headers . get ( 'content-type' ) 'application/json' Multiple values for a single response header are represented as a single comma separated value, as per RFC 7230 : A recipient MAY combine multiple header fields with the same field name into one \u201cfield-name: field-value\u201d pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.","title":"Response Headers"},{"location":"quickstart/#cookies","text":"Any cookies that are set on the response can be easily accessed: >>> r = http3 . get ( 'http://httpbin.org/cookies/set?chocolate=chip' , allow_redirects = False ) >>> r . cookies [ 'chocolate' ] 'chip' To include cookies in an outgoing request, use the cookies parameter: >>> cookies = { \"peanut\" : \"butter\" } >>> r = http3 . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'peanut' : 'butter' }} Cookies are returned in a Cookies instance, which is a dict-like data structure with additional API for accessing cookies by their domain or path. >>> cookies = http3 . Cookies () >>> cookies . set ( 'cookie_on_domain' , 'hello, there!' , domain = 'httpbin.org' ) >>> cookies . set ( 'cookie_off_domain' , 'nope.' , domain = 'example.org' ) >>> r = http3 . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'cookie_on_domain' : 'hello, there!' }}","title":"Cookies"},{"location":"quickstart/#redirection-and-history","text":"By default HTTP3 will follow redirects for anything except HEAD requests. The history property of the response can be used to inspect any followed redirects. It contains a list of all any redirect responses that were followed, in the order in which they were made. For example, GitHub redirects all HTTP requests to HTTPS. >>> r = http3 . get ( 'http://github.com/' ) >>> r . url URL ( 'https://github.com/' ) >>> r . status_code < StatusCode . OK : 200 > >>> r . history [ < Response [ 301 ] > ] You can modify the default redirection handling with the allow_redirects parameter: >>> r = http3 . get ( 'http://github.com/' , allow_redirects = False ) >>> r . status_code 301 >>> r . history [] If you\u2019re making a HEAD request, you can use this to enable redirection: >>> r = http3 . head ( 'http://github.com/' , allow_redirects = True ) >>> r . url 'https://github.com/' >>> r . history [ < Response [ 301 ] > ]","title":"Redirection and History"},{"location":"quickstart/#timeouts","text":"HTTP3 defaults to including reasonable timeouts for all network operations, meaning that if a connection is not properly established then it should always raise an error rather than hanging indefinitely. The default timeout for network inactivity is five seconds. You can modify the value to be more or less strict: >>> http3 . get ( 'https://github.com/' , timeout = 0.001 )","title":"Timeouts"}]}