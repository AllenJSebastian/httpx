{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTPX A next-generation HTTP client for Python. HTTPX is an asynchronous client library that supports HTTP/1.1 and HTTP/2. It can be used in high-performance async web frameworks, using either asyncio or trio, and is able to support making large numbers of concurrent requests. Note The 0.8 release switched HTTPX into focusing exclusively on providing an async client. It is possible that we'll look at re-introducing a sync API at a later date. Let's get started... The standard Python REPL does not allow top-level async statements. To run these async examples you'll probably want to either use ipython , or use Python 3.8 with python -m asyncio . >>> import httpx >>> r = await httpx . get ( 'https://www.example.org/' ) >>> r < Response [ 200 OK ] > >>> r . status_code 200 >>> r . http_version 'HTTP/1.1' >>> r . headers [ 'content-type' ] 'text/html; charset=UTF-8' >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Features HTTPX is a high performance asynchronous HTTP client, that builds on the well-established usability of requests , and gives you: A broadly requests-compatible API. HTTP/2 and HTTP/1.1 support. Ability to make requests directly to ASGI applications . Strict timeouts everywhere. Fully type annotated. 100% test coverage. Plus all the standard features of requests ... International Domains and URLs Keep-Alive & Connection Pooling Sessions with Cookie Persistence Browser-style SSL Verification Basic/Digest Authentication Elegant Key/Value Cookies Automatic Decompression Automatic Content Decoding Unicode Response Bodies Multipart File Uploads HTTP(S) Proxy Support Connection Timeouts Streaming Downloads .netrc Support Chunked Requests Documentation For a run-through of all the basics, head over to the QuickStart . For more advanced topics, see the Advanced Usage section. The Developer Interface provides a comprehensive API reference. Dependencies The HTTPX project relies on these excellent libraries: h2 - HTTP/2 support. h11 - HTTP/1.1 support. certifi - SSL certificates. chardet - Fallback auto-detection for response encoding. hstspreload - determines whether IDNA-encoded host should be only accessed via HTTPS. idna - Internationalized domain name support. rfc3986 - URL parsing & normalization. brotlipy - Decoding for \"brotli\" compressed responses. (Optional) A huge amount of credit is due to requests for the API layout that much of this work follows, as well as to urllib3 for plenty of design inspiration around the lower-level networking details. Installation Install with pip: $ pip install httpx HTTPX requires Python 3.6+","title":"Introduction"},{"location":"#features","text":"HTTPX is a high performance asynchronous HTTP client, that builds on the well-established usability of requests , and gives you: A broadly requests-compatible API. HTTP/2 and HTTP/1.1 support. Ability to make requests directly to ASGI applications . Strict timeouts everywhere. Fully type annotated. 100% test coverage. Plus all the standard features of requests ... International Domains and URLs Keep-Alive & Connection Pooling Sessions with Cookie Persistence Browser-style SSL Verification Basic/Digest Authentication Elegant Key/Value Cookies Automatic Decompression Automatic Content Decoding Unicode Response Bodies Multipart File Uploads HTTP(S) Proxy Support Connection Timeouts Streaming Downloads .netrc Support Chunked Requests","title":"Features"},{"location":"#documentation","text":"For a run-through of all the basics, head over to the QuickStart . For more advanced topics, see the Advanced Usage section. The Developer Interface provides a comprehensive API reference.","title":"Documentation"},{"location":"#dependencies","text":"The HTTPX project relies on these excellent libraries: h2 - HTTP/2 support. h11 - HTTP/1.1 support. certifi - SSL certificates. chardet - Fallback auto-detection for response encoding. hstspreload - determines whether IDNA-encoded host should be only accessed via HTTPS. idna - Internationalized domain name support. rfc3986 - URL parsing & normalization. brotlipy - Decoding for \"brotli\" compressed responses. (Optional) A huge amount of credit is due to requests for the API layout that much of this work follows, as well as to urllib3 for plenty of design inspiration around the lower-level networking details.","title":"Dependencies"},{"location":"#installation","text":"Install with pip: $ pip install httpx HTTPX requires Python 3.6+","title":"Installation"},{"location":"advanced/","text":"Advanced Usage Client Instances Using a Client instance to make requests will give you HTTP connection pooling, will provide cookie persistence, and allows you to apply configuration across all outgoing requests. Hint A Client instance is equivalent to a Session instance in requests . Usage The recommended way to use a Client is as a context manager. This will ensure that connections are properly cleaned up when leaving the with block: >>> async with httpx . Client () as client : ... r = await client . get ( 'https://example.com' ) ... >>> r < Response [ 200 OK ] > Alternatively, you can explicitly close the connection pool without block-usage using .close() : >>> client = httpx . Client () >>> try : ... r = await client . get ( 'https://example.com' ) ... finally : ... await client . close () ... >>> r < Response [ 200 OK ] > Once you have a Client , you can use all the features documented in the Quickstart guide. Configuration Clients allow you to apply configuration to all outgoing requests by passing parameters to the Client constructor. For example, to apply a set of custom headers on every request: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> async with httpx . Client ( headers = headers ) as client : ... r = await client . get ( url ) ... >>> r . json ()[ 'headers' ][ 'User-Agent' ] 'my-app/0.0.1' Note When you provide a parameter at both the client and request levels, one of two things can happen: For headers, query parameters and cookies, the values are merged into one. For all other parameters, the request-level value is used. Additionally, Client constructor accepts some parameters that aren't available at the request level. One particularly useful parameter is base_url , which allows you to define a base URL to prepend to all outgoing requests: >>> async with httpx . Client ( base_url = 'http://httpbin.org' ) as client : ... r = await client . get ( '/headers' ) ... >>> r . request . url URL ( 'http://httpbin.org/headers' ) For a list of all available client-level parameters, see the Client API reference . Calling into Python Web Apps You can configure an httpx client to call directly into a Python web application using either the ASGI protocol. This is particularly useful for two main use-cases: Using httpx as a client inside test cases. Mocking out external services during tests or in dev/staging environments. Let's take this Starlette application as an example: from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route async def hello (): return HTMLResponse ( \"Hello World!\" ) app = Starlette ( routes = [ Route ( \"/\" , hello )]) We can make requests directly against the application, like so: >>> import httpx >>> async with httpx . Client ( app = app ) as client : ... r = client . get ( 'http://example/' ) ... assert r . status_code == 200 ... assert r . text == \"Hello World!\" For some more complex cases you might need to customize the WSGI or ASGI dispatch. This allows you to: Inspect 500 error responses rather than raise exceptions by setting raise_app_exceptions=False . Mount the WSGI or ASGI application at a subpath by setting root_path . Use a given client address for requests by setting client . For example: # Instantiate a client that makes WSGI requests with a client IP of \"1.2.3.4\". dispatch = httpx . dispatch . ASGIDispatch ( app = app , remote_addr = \"1.2.3.4\" ) async with httpx . Client ( dispatch = dispatch ) as client : ... Build Request You can use Client.build_request() to build a request and make modifications before sending the request. >>> async with httpx . Client () as client : ... req = client . build_request ( \"OPTIONS\" , \"https://example.com\" ) ... req . url . full_path = \"*\" # Build an 'OPTIONS *' request for CORS ... r = await client . send ( req ) ... >>> r < Response [ 200 OK ] > Specify the version of the HTTP protocol One can set the version of the HTTP protocol for the client in case you want to make the requests using a specific version. For example: async with httpx . Client ( http_versions = [ \"HTTP/1.1\" ]) as h11_client : h11_response = await h11_client . get ( \"https://myserver.com\" ) async with httpx . Client ( http_versions = [ \"HTTP/2\" ]) as h2_client : h2_response = await h2_client . get ( \"https://myserver.com\" ) .netrc Support HTTPX supports .netrc file. In trust_env=True cases, if auth parameter is not defined, HTTPX tries to add auth into request's header from .netrc file. Note The NETRC file is cached across requests made by a client. If you need to refresh the cache (e.g. because the NETRC file has changed), you should create a new client or restart the interpreter. As default trust_env is true. To set false: >>> await httpx . get ( 'https://example.org/' , trust_env = False ) If NETRC environment is empty, HTTPX tries to use default files. ( ~/.netrc , ~/_netrc ) To change NETRC environment: >>> import os >>> os . environ [ \"NETRC\" ] = \"my_default_folder/.my_netrc\" .netrc file content example: machine netrcexample . org login example - username password example - password ... Unix Domain Sockets You can configure an httpx client to connect through a unix domain socket via the uds parameter. This is useful when making requests to a server that is bound to a socket file rather than an IP address. Here's an example requesting the Docker Engine API: import httpx async with httpx . Client ( uds = \"/var/run/docker.sock\" ) as client : # This request will connect through the socket file. resp = await client . get ( \"http://localhost/version\" ) HTTP Proxying HTTPX supports setting up proxies the same way that Requests does via the proxies parameter. For example to forward all HTTP traffic to http://127.0.0.1:3080 and all HTTPS traffic to http://127.0.0.1:3081 your proxies config would look like this: >>> proxies = { ... \"http\" : \"http://127.0.0.1:3080\" , ... \"https\" : \"http://127.0.0.1:3081\" ... } >>> async with httpx . Client ( proxies = proxies ) as client : ... ... Proxies can be configured for a specific scheme and host, all schemes of a host, all hosts for a scheme, or for all requests. When determining which proxy configuration to use for a given request this same order is used. >>> proxies = { ... \"http://example.com\" : \"...\" , # Host+Scheme ... \"all://example.com\" : \"...\" , # Host ... \"http\" : \"...\" , # Scheme ... \"all\" : \"...\" , # All ... } >>> async with httpx . Client ( proxies = proxies ) as client : ... ... ... >>> proxy = \"...\" # Shortcut for {'all': '...'} >>> async with httpx . Client ( proxies = proxy ) as client : ... ... Warning To make sure that proxies cannot read your traffic, and even if the proxy_url uses HTTPS, it is recommended to use HTTPS and tunnel requests if possible. By default HTTPProxy will operate as a forwarding proxy for http://... requests and will establish a CONNECT TCP tunnel for https:// requests. This doesn't change regardless of the proxy_url being http or https . Proxies can be configured to have different behavior such as forwarding or tunneling all requests: proxy = httpx . HTTPProxy ( proxy_url = \"https://127.0.0.1\" , proxy_mode = httpx . HTTPProxyMode . TUNNEL_ONLY ) async with httpx . Client ( proxies = proxy ) as client : # This request will be tunneled instead of forwarded. r = await client . get ( \"http://example.com\" ) Note Per request proxy configuration, i.e. client.get(url, proxies=...) , has not been implemented yet. To use proxies you must pass the proxy information at Client initialization. Timeout fine-tuning HTTPX offers various request timeout management options. Three types of timeouts are available: connect timeouts, write timeouts and read timeouts. The connect timeout specifies the maximum amount of time to wait until a connection to the requested host is established. If HTTPX is unable to connect within this time frame, a ConnectTimeout exception is raised. The write timeout specifies the maximum duration to wait for a chunk of data to be sent (for example, a chunk of the request body). If HTTPX is unable to send data within this time frame, a WriteTimeout exception is raised. The read timeout specifies the maximum duration to wait for a chunk of data to be received (for example, a chunk of the response body). If HTTPX is unable to receive data within this time frame, a ReadTimeout exception is raised. Setting timeouts You can set timeouts on two levels: For a given request: # Using top-level API await httpx . get ( 'http://example.com/api/v1/example' , timeout = 5 ) # Or, with a client: async with httpx . Client () as client : await client . get ( \"http://example.com/api/v1/example\" , timeout = 5 ) On a client instance, which results in the given timeout being used as a default for requests made with this client: async with httpx . Client ( timeout = 5 ) as client : await client . get ( 'http://example.com/api/v1/example' ) Besides, you can pass timeouts in two forms: A number, which sets the read, write and connect timeouts to the same value, as in the examples above. A TimeoutConfig instance, which allows to define the read, write and connect timeouts independently: timeout = httpx . TimeoutConfig ( connect_timeout = 5 , read_timeout = 10 , write_timeout = 15 ) resp = await httpx . get ( 'http://example.com/api/v1/example' , timeout = timeout ) Default timeouts By default all types of timeouts are set to 5 second. Disabling timeouts To disable timeouts, you can pass None as a timeout parameter. Note that currently this is not supported by the top-level API. url = \"http://example.com/api/v1/delay/10\" await httpx . get ( url , timeout = None ) # Times out after 5s async with httpx . Client ( timeout = None ) as client : await client . get ( url ) # Does not timeout, returns after 10s timeout = httpx . TimeoutConfig ( connect_timeout = 5 , read_timeout = None , write_timeout = 5 ) await httpx . get ( url , timeout = timeout ) # Does not timeout, returns after 10s Multipart file encoding As mentioned in the quickstart multipart file encoding is available by passing a dictionary with the name of the payloads as keys and a tuple of elements as values. >>> files = { 'upload-file' : ( 'report.xls' , open ( 'report.xls' , 'rb' ), 'application/vnd.ms-excel' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... } More specifically, this tuple must have at least two elements and maximum of three: - The first one is an optional file name which can be set to None . - The second may be a file-like object or a string which will be automatically encoded in UTF-8. - An optional third element can be included with the MIME type of the file being uploaded. If not specified HTTPX will attempt to guess the MIME type based on the file name specified as the first element or the tuple, if that is set to None or it cannot be inferred from it, HTTPX will default to applicaction/octet-stream . >>> files = { 'upload-file' : ( None , 'text content' , 'text/plain' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : {}, \"form\" : { \"upload-file\" : \"text-content\" }, ... } SSL certificates When making a request over HTTPS, HTTPX needs to verify the identity of the requested host. To do this, it uses a bundle of SSL certificates (a.k.a. CA bundle) delivered by a trusted certificate authority (CA). Default CA bundle By default, HTTPX uses the CA bundle provided by Certifi . This is what you want in most cases, even though some advanced situations may require you to use a different set of certificates. Using a custom CA bundle If you'd like to use a custom CA bundle, you can use the verify parameter that is available on the high-level API as well as clients. For example: import httpx r = await httpx . get ( \"https://example.org\" , verify = \"path/to/client.pem\" ) Making HTTPS requests to a local server When making requests to local servers, such as a development server running on localhost , you will typically be using unencrypted HTTP connections. If you do need to make HTTPS connections to a local server, for example to test an HTTPS-only service, you will need to create and use your own certificates. Here's one way to do it: Use trustme-cli to generate a pair of server key/cert files, and a client cert file. Pass the server key/cert files when starting your local server. (This depends on the particular web server you're using. For example, Uvicorn provides the --ssl-keyfile and --ssl-certfile options.) Tell HTTPX to use the certificates stored in client.pem : >>> import httpx >>> r = await httpx . get ( \"https://localhost:8000\" , verify = \"/tmp/client.pem\" ) >>> r Response < 200 OK > Support async environments asyncio (Default) By default, AsyncClient uses asyncio to perform asynchronous operations and I/O calls. trio To make asynchronous requests in trio programs, pass a TrioBackend to the AsyncClient : import trio import httpx from httpx.concurrency.trio import TrioBackend async def main (): async with httpx . AsyncClient ( backend = TrioBackend ()) as client : ... trio . run ( main ) Important trio must be installed to import and use the TrioBackend .","title":"Advanced Usage"},{"location":"advanced/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced/#client-instances","text":"Using a Client instance to make requests will give you HTTP connection pooling, will provide cookie persistence, and allows you to apply configuration across all outgoing requests. Hint A Client instance is equivalent to a Session instance in requests .","title":"Client Instances"},{"location":"advanced/#usage","text":"The recommended way to use a Client is as a context manager. This will ensure that connections are properly cleaned up when leaving the with block: >>> async with httpx . Client () as client : ... r = await client . get ( 'https://example.com' ) ... >>> r < Response [ 200 OK ] > Alternatively, you can explicitly close the connection pool without block-usage using .close() : >>> client = httpx . Client () >>> try : ... r = await client . get ( 'https://example.com' ) ... finally : ... await client . close () ... >>> r < Response [ 200 OK ] > Once you have a Client , you can use all the features documented in the Quickstart guide.","title":"Usage"},{"location":"advanced/#configuration","text":"Clients allow you to apply configuration to all outgoing requests by passing parameters to the Client constructor. For example, to apply a set of custom headers on every request: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> async with httpx . Client ( headers = headers ) as client : ... r = await client . get ( url ) ... >>> r . json ()[ 'headers' ][ 'User-Agent' ] 'my-app/0.0.1' Note When you provide a parameter at both the client and request levels, one of two things can happen: For headers, query parameters and cookies, the values are merged into one. For all other parameters, the request-level value is used. Additionally, Client constructor accepts some parameters that aren't available at the request level. One particularly useful parameter is base_url , which allows you to define a base URL to prepend to all outgoing requests: >>> async with httpx . Client ( base_url = 'http://httpbin.org' ) as client : ... r = await client . get ( '/headers' ) ... >>> r . request . url URL ( 'http://httpbin.org/headers' ) For a list of all available client-level parameters, see the Client API reference .","title":"Configuration"},{"location":"advanced/#calling-into-python-web-apps","text":"You can configure an httpx client to call directly into a Python web application using either the ASGI protocol. This is particularly useful for two main use-cases: Using httpx as a client inside test cases. Mocking out external services during tests or in dev/staging environments. Let's take this Starlette application as an example: from starlette.applications import Starlette from starlette.responses import HTMLResponse from starlette.routing import Route async def hello (): return HTMLResponse ( \"Hello World!\" ) app = Starlette ( routes = [ Route ( \"/\" , hello )]) We can make requests directly against the application, like so: >>> import httpx >>> async with httpx . Client ( app = app ) as client : ... r = client . get ( 'http://example/' ) ... assert r . status_code == 200 ... assert r . text == \"Hello World!\" For some more complex cases you might need to customize the WSGI or ASGI dispatch. This allows you to: Inspect 500 error responses rather than raise exceptions by setting raise_app_exceptions=False . Mount the WSGI or ASGI application at a subpath by setting root_path . Use a given client address for requests by setting client . For example: # Instantiate a client that makes WSGI requests with a client IP of \"1.2.3.4\". dispatch = httpx . dispatch . ASGIDispatch ( app = app , remote_addr = \"1.2.3.4\" ) async with httpx . Client ( dispatch = dispatch ) as client : ...","title":"Calling into Python Web Apps"},{"location":"advanced/#build-request","text":"You can use Client.build_request() to build a request and make modifications before sending the request. >>> async with httpx . Client () as client : ... req = client . build_request ( \"OPTIONS\" , \"https://example.com\" ) ... req . url . full_path = \"*\" # Build an 'OPTIONS *' request for CORS ... r = await client . send ( req ) ... >>> r < Response [ 200 OK ] >","title":"Build Request"},{"location":"advanced/#specify-the-version-of-the-http-protocol","text":"One can set the version of the HTTP protocol for the client in case you want to make the requests using a specific version. For example: async with httpx . Client ( http_versions = [ \"HTTP/1.1\" ]) as h11_client : h11_response = await h11_client . get ( \"https://myserver.com\" ) async with httpx . Client ( http_versions = [ \"HTTP/2\" ]) as h2_client : h2_response = await h2_client . get ( \"https://myserver.com\" )","title":"Specify the version of the HTTP protocol"},{"location":"advanced/#netrc-support","text":"HTTPX supports .netrc file. In trust_env=True cases, if auth parameter is not defined, HTTPX tries to add auth into request's header from .netrc file. Note The NETRC file is cached across requests made by a client. If you need to refresh the cache (e.g. because the NETRC file has changed), you should create a new client or restart the interpreter. As default trust_env is true. To set false: >>> await httpx . get ( 'https://example.org/' , trust_env = False ) If NETRC environment is empty, HTTPX tries to use default files. ( ~/.netrc , ~/_netrc ) To change NETRC environment: >>> import os >>> os . environ [ \"NETRC\" ] = \"my_default_folder/.my_netrc\" .netrc file content example: machine netrcexample . org login example - username password example - password ...","title":".netrc Support"},{"location":"advanced/#unix-domain-sockets","text":"You can configure an httpx client to connect through a unix domain socket via the uds parameter. This is useful when making requests to a server that is bound to a socket file rather than an IP address. Here's an example requesting the Docker Engine API: import httpx async with httpx . Client ( uds = \"/var/run/docker.sock\" ) as client : # This request will connect through the socket file. resp = await client . get ( \"http://localhost/version\" )","title":"Unix Domain Sockets"},{"location":"advanced/#http-proxying","text":"HTTPX supports setting up proxies the same way that Requests does via the proxies parameter. For example to forward all HTTP traffic to http://127.0.0.1:3080 and all HTTPS traffic to http://127.0.0.1:3081 your proxies config would look like this: >>> proxies = { ... \"http\" : \"http://127.0.0.1:3080\" , ... \"https\" : \"http://127.0.0.1:3081\" ... } >>> async with httpx . Client ( proxies = proxies ) as client : ... ... Proxies can be configured for a specific scheme and host, all schemes of a host, all hosts for a scheme, or for all requests. When determining which proxy configuration to use for a given request this same order is used. >>> proxies = { ... \"http://example.com\" : \"...\" , # Host+Scheme ... \"all://example.com\" : \"...\" , # Host ... \"http\" : \"...\" , # Scheme ... \"all\" : \"...\" , # All ... } >>> async with httpx . Client ( proxies = proxies ) as client : ... ... ... >>> proxy = \"...\" # Shortcut for {'all': '...'} >>> async with httpx . Client ( proxies = proxy ) as client : ... ... Warning To make sure that proxies cannot read your traffic, and even if the proxy_url uses HTTPS, it is recommended to use HTTPS and tunnel requests if possible. By default HTTPProxy will operate as a forwarding proxy for http://... requests and will establish a CONNECT TCP tunnel for https:// requests. This doesn't change regardless of the proxy_url being http or https . Proxies can be configured to have different behavior such as forwarding or tunneling all requests: proxy = httpx . HTTPProxy ( proxy_url = \"https://127.0.0.1\" , proxy_mode = httpx . HTTPProxyMode . TUNNEL_ONLY ) async with httpx . Client ( proxies = proxy ) as client : # This request will be tunneled instead of forwarded. r = await client . get ( \"http://example.com\" ) Note Per request proxy configuration, i.e. client.get(url, proxies=...) , has not been implemented yet. To use proxies you must pass the proxy information at Client initialization.","title":"HTTP Proxying"},{"location":"advanced/#timeout-fine-tuning","text":"HTTPX offers various request timeout management options. Three types of timeouts are available: connect timeouts, write timeouts and read timeouts. The connect timeout specifies the maximum amount of time to wait until a connection to the requested host is established. If HTTPX is unable to connect within this time frame, a ConnectTimeout exception is raised. The write timeout specifies the maximum duration to wait for a chunk of data to be sent (for example, a chunk of the request body). If HTTPX is unable to send data within this time frame, a WriteTimeout exception is raised. The read timeout specifies the maximum duration to wait for a chunk of data to be received (for example, a chunk of the response body). If HTTPX is unable to receive data within this time frame, a ReadTimeout exception is raised.","title":"Timeout fine-tuning"},{"location":"advanced/#setting-timeouts","text":"You can set timeouts on two levels: For a given request: # Using top-level API await httpx . get ( 'http://example.com/api/v1/example' , timeout = 5 ) # Or, with a client: async with httpx . Client () as client : await client . get ( \"http://example.com/api/v1/example\" , timeout = 5 ) On a client instance, which results in the given timeout being used as a default for requests made with this client: async with httpx . Client ( timeout = 5 ) as client : await client . get ( 'http://example.com/api/v1/example' ) Besides, you can pass timeouts in two forms: A number, which sets the read, write and connect timeouts to the same value, as in the examples above. A TimeoutConfig instance, which allows to define the read, write and connect timeouts independently: timeout = httpx . TimeoutConfig ( connect_timeout = 5 , read_timeout = 10 , write_timeout = 15 ) resp = await httpx . get ( 'http://example.com/api/v1/example' , timeout = timeout )","title":"Setting timeouts"},{"location":"advanced/#default-timeouts","text":"By default all types of timeouts are set to 5 second.","title":"Default timeouts"},{"location":"advanced/#disabling-timeouts","text":"To disable timeouts, you can pass None as a timeout parameter. Note that currently this is not supported by the top-level API. url = \"http://example.com/api/v1/delay/10\" await httpx . get ( url , timeout = None ) # Times out after 5s async with httpx . Client ( timeout = None ) as client : await client . get ( url ) # Does not timeout, returns after 10s timeout = httpx . TimeoutConfig ( connect_timeout = 5 , read_timeout = None , write_timeout = 5 ) await httpx . get ( url , timeout = timeout ) # Does not timeout, returns after 10s","title":"Disabling timeouts"},{"location":"advanced/#multipart-file-encoding","text":"As mentioned in the quickstart multipart file encoding is available by passing a dictionary with the name of the payloads as keys and a tuple of elements as values. >>> files = { 'upload-file' : ( 'report.xls' , open ( 'report.xls' , 'rb' ), 'application/vnd.ms-excel' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... } More specifically, this tuple must have at least two elements and maximum of three: - The first one is an optional file name which can be set to None . - The second may be a file-like object or a string which will be automatically encoded in UTF-8. - An optional third element can be included with the MIME type of the file being uploaded. If not specified HTTPX will attempt to guess the MIME type based on the file name specified as the first element or the tuple, if that is set to None or it cannot be inferred from it, HTTPX will default to applicaction/octet-stream . >>> files = { 'upload-file' : ( None , 'text content' , 'text/plain' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : {}, \"form\" : { \"upload-file\" : \"text-content\" }, ... }","title":"Multipart file encoding"},{"location":"advanced/#ssl-certificates","text":"When making a request over HTTPS, HTTPX needs to verify the identity of the requested host. To do this, it uses a bundle of SSL certificates (a.k.a. CA bundle) delivered by a trusted certificate authority (CA).","title":"SSL certificates"},{"location":"advanced/#default-ca-bundle","text":"By default, HTTPX uses the CA bundle provided by Certifi . This is what you want in most cases, even though some advanced situations may require you to use a different set of certificates.","title":"Default CA bundle"},{"location":"advanced/#using-a-custom-ca-bundle","text":"If you'd like to use a custom CA bundle, you can use the verify parameter that is available on the high-level API as well as clients. For example: import httpx r = await httpx . get ( \"https://example.org\" , verify = \"path/to/client.pem\" )","title":"Using a custom CA bundle"},{"location":"advanced/#making-https-requests-to-a-local-server","text":"When making requests to local servers, such as a development server running on localhost , you will typically be using unencrypted HTTP connections. If you do need to make HTTPS connections to a local server, for example to test an HTTPS-only service, you will need to create and use your own certificates. Here's one way to do it: Use trustme-cli to generate a pair of server key/cert files, and a client cert file. Pass the server key/cert files when starting your local server. (This depends on the particular web server you're using. For example, Uvicorn provides the --ssl-keyfile and --ssl-certfile options.) Tell HTTPX to use the certificates stored in client.pem : >>> import httpx >>> r = await httpx . get ( \"https://localhost:8000\" , verify = \"/tmp/client.pem\" ) >>> r Response < 200 OK >","title":"Making HTTPS requests to a local server"},{"location":"advanced/#support-async-environments","text":"","title":"Support async environments"},{"location":"advanced/#asyncio-default","text":"By default, AsyncClient uses asyncio to perform asynchronous operations and I/O calls.","title":"asyncio (Default)"},{"location":"advanced/#trio","text":"To make asynchronous requests in trio programs, pass a TrioBackend to the AsyncClient : import trio import httpx from httpx.concurrency.trio import TrioBackend async def main (): async with httpx . AsyncClient ( backend = TrioBackend ()) as client : ... trio . run ( main ) Important trio must be installed to import and use the TrioBackend .","title":"trio"},{"location":"api/","text":"Developer Interface Helper Functions Note Only use these functions if you're testing HTTPX in a console or making a small number of requests. Using a Client will enable HTTP/2 and connection pooling for more efficient and long-lived connections. httpx. request ( method , url , * , params=None , data=None , files=None , json=None , headers=None , cookies=None , auth=None , timeout=TimeoutConfig(timeout=5.0) , allow_redirects=True , verify=True , cert=None , stream=False , trust_env=True ) Sends an HTTP request. Parameters: method - HTTP method for the new Request object: GET , OPTIONS , HEAD , POST , PUT , PATCH , or DELETE . url - URL for the new Request object. params - (optional) Query parameters to include in the URL, as a string, dictionary, or list of two-tuples. data - (optional) Data to include in the body of the request, as a dictionary files - (optional) A dictionary of upload files to include in the body of the request. json - (optional) A JSON serializable object to include in the body of the request. headers - (optional) Dictionary of HTTP headers to include in the request. cookies - (optional) Dictionary of Cookie items to include in the request. auth - (optional) An authentication class to use when sending the request. timeout - (optional) The timeout configuration to use when sending the request. allow_redirects - (optional) Enables or disables HTTP redirects. verify - (optional) SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either True (default CA bundle), a path to an SSL certificate file, or False (disable verification). cert - (optional) An SSL certificate used by the requested host to authenticate the client. Either a path to an SSL certificate file, or two-tuple of (certificate file, key file), or a three-tuple of (certificate file, key file, password). trust_env - (optional) Enables or disables usage of environment variables for configuration. proxies - (optional) A dictionary mapping HTTP protocols to proxy URLs. Returns: Response Usage: >>> import httpx >>> response = await httpx . request ( 'GET' , 'https://httpbin.org/get' ) >>> response < Response [ 200 OK ] > httpx. get ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a GET request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as GET requests should not include a request body. httpx. options ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends an OPTIONS request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as OPTIONS requests should not include a request body. httpx. head ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=False , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a HEAD request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as HEAD requests should not include a request body. The HEAD method also differs from the other cases in that allow_redirects defaults to False . httpx. post ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a POST request. Parameters : See httpx.request . httpx. put ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a PUT request. Parameters : See httpx.request . httpx. patch ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a PATCH request. Parameters : See httpx.request . httpx. delete ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a DELETE request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as DELETE requests should not include a request body. Client class httpx. Client ( * , auth=None , params=None , headers=None , cookies=None , verify=True , cert=None , http_versions=None , proxies=None , timeout=TimeoutConfig(timeout=5.0) , pool_limits=PoolLimits(soft_limit=10, hard_limit=100, pool_timeout=5.0) , max_redirects=20 , base_url=None , dispatch=None , app=None , backend=None , trust_env=True , uds=None ) An HTTP client, with connection pooling, HTTP/2, redirects, cookie persistence, etc. Usage: >>> client = httpx.Client() >>> response = client.get('https://example.org') Parameters: auth - (optional) An authentication class to use when sending requests. params - (optional) Query parameters to include in request URLs, as a string, dictionary, or list of two-tuples. headers - (optional) Dictionary of HTTP headers to include when sending requests. cookies - (optional) Dictionary of Cookie items to include when sending requests. verify - (optional) SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either True (default CA bundle), a path to an SSL certificate file, or False (disable verification). cert - (optional) An SSL certificate used by the requested host to authenticate the client. Either a path to an SSL certificate file, or two-tuple of (certificate file, key file), or a three-tuple of (certificate file, key file, password). http_versions - (optional) A list of strings of HTTP protocol versions to use when sending requests. eg. http_versions=[\"HTTP/1.1\"] proxies - (optional) A dictionary mapping HTTP protocols to proxy URLs. timeout - (optional) The timeout configuration to use when sending requests. pool_limits - (optional) The connection pool configuration to use when determining the maximum number of concurrently open HTTP connections. max_redirects - (optional) The maximum number of redirect responses that should be followed. base_url - (optional) A URL to use as the base when building request URLs. dispatch - (optional) A dispatch class to use for sending requests over the network. app - (optional) An ASGI application to send requests to, rather than sending actual network requests. backend - (optional) A concurrency backend to use when issuing async requests. trust_env - (optional) Enables or disables usage of environment variables for configuration. uds - (optional) A path to a Unix domain socket to connect through. headers HTTP headers to include when sending requests. cookies Cookie values to include when sending requests. params Query parameters to include in the URL when sending requests. request ( self , method , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) get ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) head ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=False , cert=None , verify=None , timeout=None , trust_env=None ) options ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) post ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) put ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) patch ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) delete ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) build_request ( self , method , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None ) Build and return a request instance. send ( self , request , * , stream=False , auth=None , allow_redirects=True , verify=None , cert=None , timeout=None , trust_env=None ) close ( self ) Response An HTTP response. def __init__(...) .status_code - int .reason_phrase - str .http_version - \"HTTP/2\" or \"HTTP/1.1\" .url - URL .headers - Headers .content - bytes .text - str .encoding - str .is_redirect - bool .request - Request .cookies - Cookies .history - List[Response] .elapsed - timedelta The amount of time elapsed between sending the first byte and parsing the headers (not including time spent reading the response). Use total_seconds() to correctly get the total elapsed seconds. def .raise_for_status() - None def .json() - Any def .read() - bytes def .stream() - bytes iterator def .raw() - bytes iterator def .close() - None def .next() - Response Request An HTTP request. Can be constructed explicitly for more control over exactly what gets sent over the wire. >>> request = httpx . Request ( \"GET\" , \"https://example.org\" , headers = { 'host' : 'example.org' }) >>> response = await client . send ( request ) def __init__(method, url, [params], [data], [json], [headers], [cookies]) .method - str .url - URL .content - byte or byte async iterator .headers - Headers .cookies - Cookies URL A normalized, IDNA supporting URL. >>> url = URL ( \"https://example.org/\" ) >>> url . host 'example.org' def __init__(url, allow_relative=False, params=None) .scheme - str .authority - str .host - str .port - int .path - str .query - str .full_path - str .fragment - str .is_ssl - bool .origin - Origin .is_absolute_url - bool .is_relative_url - bool def .copy_with([scheme], [authority], [path], [query], [fragment]) - URL def .resolve_with(url) - URL Origin A normalized, IDNA supporting set of scheme/host/port info. >>> Origin ( 'https://example.org' ) == Origin ( 'HTTPS://EXAMPLE.ORG:443' ) True def __init__(url) .scheme - str .is_ssl - bool .host - str .port - int Headers A case-insensitive multi-dict. >>> headers = Headers ({ 'Content-Type' : 'application/json' }) >>> headers [ 'content-type' ] 'application/json' def __init__(self, headers) Cookies A dict-like cookie store. >>> cookies = Cookies () >>> cookies . set ( \"name\" , \"value\" , domain = \"example.org\" ) def __init__(cookies: [dict, Cookies, CookieJar]) .jar - CookieJar def extract_cookies(response) def set_cookie_header(request) def set(name, value, [domain], [path]) def get(name, [domain], [path]) def delete(name, [domain], [path]) def clear([domain], [path]) Standard mutable mapping interface","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#helper-functions","text":"Note Only use these functions if you're testing HTTPX in a console or making a small number of requests. Using a Client will enable HTTP/2 and connection pooling for more efficient and long-lived connections. httpx. request ( method , url , * , params=None , data=None , files=None , json=None , headers=None , cookies=None , auth=None , timeout=TimeoutConfig(timeout=5.0) , allow_redirects=True , verify=True , cert=None , stream=False , trust_env=True ) Sends an HTTP request. Parameters: method - HTTP method for the new Request object: GET , OPTIONS , HEAD , POST , PUT , PATCH , or DELETE . url - URL for the new Request object. params - (optional) Query parameters to include in the URL, as a string, dictionary, or list of two-tuples. data - (optional) Data to include in the body of the request, as a dictionary files - (optional) A dictionary of upload files to include in the body of the request. json - (optional) A JSON serializable object to include in the body of the request. headers - (optional) Dictionary of HTTP headers to include in the request. cookies - (optional) Dictionary of Cookie items to include in the request. auth - (optional) An authentication class to use when sending the request. timeout - (optional) The timeout configuration to use when sending the request. allow_redirects - (optional) Enables or disables HTTP redirects. verify - (optional) SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either True (default CA bundle), a path to an SSL certificate file, or False (disable verification). cert - (optional) An SSL certificate used by the requested host to authenticate the client. Either a path to an SSL certificate file, or two-tuple of (certificate file, key file), or a three-tuple of (certificate file, key file, password). trust_env - (optional) Enables or disables usage of environment variables for configuration. proxies - (optional) A dictionary mapping HTTP protocols to proxy URLs. Returns: Response Usage: >>> import httpx >>> response = await httpx . request ( 'GET' , 'https://httpbin.org/get' ) >>> response < Response [ 200 OK ] > httpx. get ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a GET request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as GET requests should not include a request body. httpx. options ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends an OPTIONS request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as OPTIONS requests should not include a request body. httpx. head ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=False , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a HEAD request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as HEAD requests should not include a request body. The HEAD method also differs from the other cases in that allow_redirects defaults to False . httpx. post ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a POST request. Parameters : See httpx.request . httpx. put ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a PUT request. Parameters : See httpx.request . httpx. patch ( url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a PATCH request. Parameters : See httpx.request . httpx. delete ( url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=True , timeout=TimeoutConfig(timeout=5.0) , trust_env=True ) Sends a DELETE request. Parameters : See httpx.request . Note that the data , files , and json parameters are not available on this function, as DELETE requests should not include a request body.","title":"Helper Functions"},{"location":"api/#client","text":"class httpx. Client ( * , auth=None , params=None , headers=None , cookies=None , verify=True , cert=None , http_versions=None , proxies=None , timeout=TimeoutConfig(timeout=5.0) , pool_limits=PoolLimits(soft_limit=10, hard_limit=100, pool_timeout=5.0) , max_redirects=20 , base_url=None , dispatch=None , app=None , backend=None , trust_env=True , uds=None ) An HTTP client, with connection pooling, HTTP/2, redirects, cookie persistence, etc. Usage: >>> client = httpx.Client() >>> response = client.get('https://example.org') Parameters: auth - (optional) An authentication class to use when sending requests. params - (optional) Query parameters to include in request URLs, as a string, dictionary, or list of two-tuples. headers - (optional) Dictionary of HTTP headers to include when sending requests. cookies - (optional) Dictionary of Cookie items to include when sending requests. verify - (optional) SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts. Either True (default CA bundle), a path to an SSL certificate file, or False (disable verification). cert - (optional) An SSL certificate used by the requested host to authenticate the client. Either a path to an SSL certificate file, or two-tuple of (certificate file, key file), or a three-tuple of (certificate file, key file, password). http_versions - (optional) A list of strings of HTTP protocol versions to use when sending requests. eg. http_versions=[\"HTTP/1.1\"] proxies - (optional) A dictionary mapping HTTP protocols to proxy URLs. timeout - (optional) The timeout configuration to use when sending requests. pool_limits - (optional) The connection pool configuration to use when determining the maximum number of concurrently open HTTP connections. max_redirects - (optional) The maximum number of redirect responses that should be followed. base_url - (optional) A URL to use as the base when building request URLs. dispatch - (optional) A dispatch class to use for sending requests over the network. app - (optional) An ASGI application to send requests to, rather than sending actual network requests. backend - (optional) A concurrency backend to use when issuing async requests. trust_env - (optional) Enables or disables usage of environment variables for configuration. uds - (optional) A path to a Unix domain socket to connect through. headers HTTP headers to include when sending requests. cookies Cookie values to include when sending requests. params Query parameters to include in the URL when sending requests. request ( self , method , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) get ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) head ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=False , cert=None , verify=None , timeout=None , trust_env=None ) options ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) post ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) put ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) patch ( self , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) delete ( self , url , * , params=None , headers=None , cookies=None , stream=False , auth=None , allow_redirects=True , cert=None , verify=None , timeout=None , trust_env=None ) build_request ( self , method , url , * , data=None , files=None , json=None , params=None , headers=None , cookies=None ) Build and return a request instance. send ( self , request , * , stream=False , auth=None , allow_redirects=True , verify=None , cert=None , timeout=None , trust_env=None ) close ( self )","title":"Client"},{"location":"api/#response","text":"An HTTP response. def __init__(...) .status_code - int .reason_phrase - str .http_version - \"HTTP/2\" or \"HTTP/1.1\" .url - URL .headers - Headers .content - bytes .text - str .encoding - str .is_redirect - bool .request - Request .cookies - Cookies .history - List[Response] .elapsed - timedelta The amount of time elapsed between sending the first byte and parsing the headers (not including time spent reading the response). Use total_seconds() to correctly get the total elapsed seconds. def .raise_for_status() - None def .json() - Any def .read() - bytes def .stream() - bytes iterator def .raw() - bytes iterator def .close() - None def .next() - Response","title":"Response"},{"location":"api/#request","text":"An HTTP request. Can be constructed explicitly for more control over exactly what gets sent over the wire. >>> request = httpx . Request ( \"GET\" , \"https://example.org\" , headers = { 'host' : 'example.org' }) >>> response = await client . send ( request ) def __init__(method, url, [params], [data], [json], [headers], [cookies]) .method - str .url - URL .content - byte or byte async iterator .headers - Headers .cookies - Cookies","title":"Request"},{"location":"api/#url","text":"A normalized, IDNA supporting URL. >>> url = URL ( \"https://example.org/\" ) >>> url . host 'example.org' def __init__(url, allow_relative=False, params=None) .scheme - str .authority - str .host - str .port - int .path - str .query - str .full_path - str .fragment - str .is_ssl - bool .origin - Origin .is_absolute_url - bool .is_relative_url - bool def .copy_with([scheme], [authority], [path], [query], [fragment]) - URL def .resolve_with(url) - URL","title":"URL"},{"location":"api/#origin","text":"A normalized, IDNA supporting set of scheme/host/port info. >>> Origin ( 'https://example.org' ) == Origin ( 'HTTPS://EXAMPLE.ORG:443' ) True def __init__(url) .scheme - str .is_ssl - bool .host - str .port - int","title":"Origin"},{"location":"api/#headers","text":"A case-insensitive multi-dict. >>> headers = Headers ({ 'Content-Type' : 'application/json' }) >>> headers [ 'content-type' ] 'application/json' def __init__(self, headers)","title":"Headers"},{"location":"api/#cookies","text":"A dict-like cookie store. >>> cookies = Cookies () >>> cookies . set ( \"name\" , \"value\" , domain = \"example.org\" ) def __init__(cookies: [dict, Cookies, CookieJar]) .jar - CookieJar def extract_cookies(response) def set_cookie_header(request) def set(name, value, [domain], [path]) def get(name, [domain], [path]) def delete(name, [domain], [path]) def clear([domain], [path]) Standard mutable mapping interface","title":"Cookies"},{"location":"compatibility/","text":"Requests Compatibility Guide HTTPX aims to be compatible with the requests API wherever possible. This documentation outlines places where the API differs... QuickStart Pretty much any API mentioned in the requests QuickStart should be identical to the API in our own documentation. The following exceptions apply: Response.url - Returns a URL instance, rather than a string. Use str(response.url) if you need a string instance. httpx.codes - In our documentation we prefer the uppercased versions, such as codes.NOT_FOUND , but also provide lower-cased versions for API compatibility with requests . stream=True . - Streaming responses provide the .stream() and .raw() byte iterator interfaces, rather than the .iter_content() method and the .raw socket interface. .get , .delete , .head , .options - These methods do not support files , data , or json arguments. Use .request if you need to need to send data using these http methods. Advanced Usage requests.Session The HTTPX equivalent of requests.Session is httpx.Client . session = requests . Session ( ** kwargs ) is generally equivalent to client = httpx . Client ( ** kwargs ) More detailed documentation and usage of Client can be found in Advanced Usage . Mocking If you need to mock HTTPX the same way that test utilities like responses and requests-mock does for requests , see RESPX .","title":"Requests Compatibility"},{"location":"compatibility/#requests-compatibility-guide","text":"HTTPX aims to be compatible with the requests API wherever possible. This documentation outlines places where the API differs...","title":"Requests Compatibility Guide"},{"location":"compatibility/#quickstart","text":"Pretty much any API mentioned in the requests QuickStart should be identical to the API in our own documentation. The following exceptions apply: Response.url - Returns a URL instance, rather than a string. Use str(response.url) if you need a string instance. httpx.codes - In our documentation we prefer the uppercased versions, such as codes.NOT_FOUND , but also provide lower-cased versions for API compatibility with requests . stream=True . - Streaming responses provide the .stream() and .raw() byte iterator interfaces, rather than the .iter_content() method and the .raw socket interface. .get , .delete , .head , .options - These methods do not support files , data , or json arguments. Use .request if you need to need to send data using these http methods.","title":"QuickStart"},{"location":"compatibility/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"compatibility/#requestssession","text":"The HTTPX equivalent of requests.Session is httpx.Client . session = requests . Session ( ** kwargs ) is generally equivalent to client = httpx . Client ( ** kwargs ) More detailed documentation and usage of Client can be found in Advanced Usage .","title":"requests.Session"},{"location":"compatibility/#mocking","text":"If you need to mock HTTPX the same way that test utilities like responses and requests-mock does for requests , see RESPX .","title":"Mocking"},{"location":"contributing/","text":"Contributing Thank you for being interested in contributing to HTTPX. There are many ways you can contribute to the project: Try HTTPX and report bugs/issues you find Implement new features Review Pull Requests of others Write documentation Participate in discussions Reporting Bugs or Other Issues Found something that HTTPX should support? Stumbled upon some unexpected behavior? Feel free to open an issue at the issue tracker . Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: OS platform Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet Error traceback Development To start developing HTTPX create a fork of the HTTPX repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/httpx With the repository cloned you can access its folder, set up the virtual environment, install the project requirements, and then install HTTPX on edit mode: $ cd httpx $ python3 -m venv venv $ source venv/bin/activate $ pip install -r test-requirements.txt $ pip install -e . Note Feel free to replace this step with your development environment setup (pyenv, pipenv, virtualenvwrapper, docker, etc). Testing and Linting We use nox to automate testing, linting, and documentation building workflow. Make sure you have it installed at your system before starting. Install nox with: $ python3 -m pip install --user nox Alternatively, use pipx if you prefer to keep it into an isolated environment: $ pipx install nox Now, with nox installed, run the complete pipeline with: $ nox Warning The test suite spawns a testing server at the port 8000 . Make sure this isn't being used, so the tests can run properly. To run the code auto-formatting separately: $ nox -s lint Also, if you need to run the tests only: $ nox -s test You can also run a single test script like this: $ nox -s test -- tests/test_multipart.py Lastly, to ensure you're on track to pass the CI build, run: $ scripts/test This command is a light wrapper around nox that will run code style checks and test the code against all installed Python versions. Documenting Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ nox -s serve Resolving Build / Travis Failures Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail: NOX_SESSION=check Job Failed This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: nox -s check It may be worth it to run nox -s lint to attempt auto-formatting the code and if that job succeeds commit the changes. NOX_SESSION=docs Job Failed This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml . NOX_SESSION=test-3.X Job Failed This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage isn't 100% you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00% Look at the coverage report from codecov for the pull request for help debugging coverage. Releasing This section is targeted at HTTPX maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #362 . Once the release PR is merged, run $ scripts/publish to publish the new release to PyPI.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for being interested in contributing to HTTPX. There are many ways you can contribute to the project: Try HTTPX and report bugs/issues you find Implement new features Review Pull Requests of others Write documentation Participate in discussions","title":"Contributing"},{"location":"contributing/#reporting-bugs-or-other-issues","text":"Found something that HTTPX should support? Stumbled upon some unexpected behavior? Feel free to open an issue at the issue tracker . Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like: OS platform Python version Installed dependencies and versions ( python -m pip freeze ) Code snippet Error traceback","title":"Reporting Bugs or Other Issues"},{"location":"contributing/#development","text":"To start developing HTTPX create a fork of the HTTPX repository on GitHub. Then clone your fork with the following command replacing YOUR-USERNAME with your GitHub username: $ git clone https://github.com/YOUR-USERNAME/httpx With the repository cloned you can access its folder, set up the virtual environment, install the project requirements, and then install HTTPX on edit mode: $ cd httpx $ python3 -m venv venv $ source venv/bin/activate $ pip install -r test-requirements.txt $ pip install -e . Note Feel free to replace this step with your development environment setup (pyenv, pipenv, virtualenvwrapper, docker, etc).","title":"Development"},{"location":"contributing/#testing-and-linting","text":"We use nox to automate testing, linting, and documentation building workflow. Make sure you have it installed at your system before starting. Install nox with: $ python3 -m pip install --user nox Alternatively, use pipx if you prefer to keep it into an isolated environment: $ pipx install nox Now, with nox installed, run the complete pipeline with: $ nox Warning The test suite spawns a testing server at the port 8000 . Make sure this isn't being used, so the tests can run properly. To run the code auto-formatting separately: $ nox -s lint Also, if you need to run the tests only: $ nox -s test You can also run a single test script like this: $ nox -s test -- tests/test_multipart.py Lastly, to ensure you're on track to pass the CI build, run: $ scripts/test This command is a light wrapper around nox that will run code style checks and test the code against all installed Python versions.","title":"Testing and Linting"},{"location":"contributing/#documenting","text":"Documentation pages are located under the docs/ folder. To run the documentation site locally (useful for previewing changes), use: $ nox -s serve","title":"Documenting"},{"location":"contributing/#resolving-build-travis-failures","text":"Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed. Here are some common ways the test suite can fail:","title":"Resolving Build / Travis Failures"},{"location":"contributing/#nox_sessioncheck-job-failed","text":"This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run: nox -s check It may be worth it to run nox -s lint to attempt auto-formatting the code and if that job succeeds commit the changes.","title":"NOX_SESSION=check Job Failed"},{"location":"contributing/#nox_sessiondocs-job-failed","text":"This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within mkdocs.yml .","title":"NOX_SESSION=docs Job Failed"},{"location":"contributing/#nox_sessiontest-3x-job-failed","text":"This job failing means the unit tests failed or not all code paths are covered by unit tests. If tests are failing you will see this message under the coverage report: === 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s === If tests succeed but coverage isn't 100% you will see this message under the coverage report: FAIL Required test coverage of 100% not reached. Total coverage: 99.00% Look at the coverage report from codecov for the pull request for help debugging coverage.","title":"NOX_SESSION=test-3.X Job Failed"},{"location":"contributing/#releasing","text":"This section is targeted at HTTPX maintainers. Before releasing a new version, create a pull request that includes: An update to the changelog : We follow the format from keepachangelog . Compare master with the tag of the latest release, and list all entries that are of interest to our users: Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes. Things that should not go in the changelog: changes to documentation, tests or tooling. Try sorting entries in descending order of impact / importance. Keep it concise and to-the-point. \ud83c\udfaf A version bump : see __version__.py . For an example, see #362 . Once the release PR is merged, run $ scripts/publish to publish the new release to PyPI.","title":"Releasing"},{"location":"environment_variables/","text":"Environment Variables The HTTPX library can be configured via environment variables. Environment variables are used by default. To ignore environment variables, trust_env has to be set False . There are two ways to set trust_env to disable environment variables: On the client via httpx.Client(trust_env=False) Per request via client.get(\"<url>\", trust_env=False) Here is a list of environment variables that HTTPX recognizes and what function they serve: HTTPX_LOG_LEVEL Valid values: debug , trace (case-insensitive) If set to debug , then HTTP requests will be logged to stderr . This is useful for general purpose reporting of network activity. If set to trace , then low-level details about the execution of HTTP requests will be logged to stderr , in addition to debug log lines. This can help you debug issues and see what's exactly being sent over the wire and to which location. Example: # test_script.py import httpx with httpx . Client () as client : r = client . get ( \"https://google.com\" ) Debug output: $ HTTPX_LOG_LEVEL = debug python test_script.py DEBUG [2019-11-06 19:11:24] httpx.client - HTTP Request: GET https://google.com \"HTTP/1.1 301 Moved Permanently\" DEBUG [2019-11-06 19:11:24] httpx.client - HTTP Request: GET https://www.google.com/ \"HTTP/1.1 200 OK\" Trace output: $ HTTPX_LOG_LEVEL = trace python test_script.py TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - acquire_connection origin=Origin(scheme='https' host='google.com' port=443) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - new_connection connection=HTTPConnection(origin=Origin(scheme='https' host='google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.config - load_ssl_context verify=True cert=None trust_env=True http_versions=HTTPVersionConfig(['HTTP/1.1', 'HTTP/2']) TRACE [2019-11-06 19:18:56] httpx.config - load_verify_locations cafile=/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/certifi/cacert.pem TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - start_connect host='google.com' port=443 timeout=TimeoutConfig(timeout=5.0) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - connected http_version='HTTP/2' TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - send_headers stream_id=1 method='GET' target='/' headers=[(b':method', b'GET'), (b':authority', b'google.com'), (b':scheme', b'https'), (b':path', b'/'), (b'user-agent', b'python-httpx/0.7.6'), (b'accept', b'*/*'), (b'accept-encoding', b'gzip, deflate, br'), (b'connection', b'keep-alive')] TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - end_stream stream_id=1 TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<RemoteSettingsChanged changed_settings:{ChangedSetting(setting=SettingCodes.MAX_CONCURRENT_STREAMS, original_value=None, new_value=100), ChangedSetting(setting=SettingCodes.INITIAL_WINDOW_SIZE, original_value=65535, new_value=1048576), ChangedSetting(setting=SettingCodes.MAX_HEADER_LIST_SIZE, original_value=None, new_value=16384)}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<WindowUpdated stream_id:0, delta:983041> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<SettingsAcknowledged changed_settings:{}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<ResponseReceived stream_id:1, headers:[(b':status', b'301'), (b'location', b'https://www.google.com/'), (b'content-type', b'text/html; charset=UTF-8'), (b'date', b'Wed, 06 Nov 2019 18:18:56 GMT'), (b'expires', b'Fri, 06 Dec 2019 18:18:56 GMT'), (b'cache-control', b'public, max-age=2592000'), (b'server', b'gws'), (b'content-length', b'220'), (b'x-xss-protection', b'0'), (b'x-frame-options', b'SAMEORIGIN'), (b'alt-svc', b'quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q050=\":443\"; ma=2592000,h3-Q049=\":443\"; ma=2592000,h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000')]> DEBUG [2019-11-06 19:18:56] httpx.client - HTTP Request: GET https://google.com \"HTTP/2 301 Moved Permanently\" TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - acquire_connection origin=Origin(scheme='https' host='www.google.com' port=443) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - new_connection connection=HTTPConnection(origin=Origin(scheme='https' host='www.google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.config - load_ssl_context verify=True cert=None trust_env=True http_versions=HTTPVersionConfig(['HTTP/1.1', 'HTTP/2']) TRACE [2019-11-06 19:18:56] httpx.config - load_verify_locations cafile=/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/certifi/cacert.pem TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - start_connect host='www.google.com' port=443 timeout=TimeoutConfig(timeout=5.0) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - connected http_version='HTTP/2' TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - send_headers stream_id=1 method='GET' target='/' headers=[(b':method', b'GET'), (b':authority', b'www.google.com'), (b':scheme', b'https'), (b':path', b'/'), (b'user-agent', b'python-httpx/0.7.6'), (b'accept', b'*/*'), (b'accept-encoding', b'gzip, deflate, br'), (b'connection', b'keep-alive')] TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - end_stream stream_id=1 TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<RemoteSettingsChanged changed_settings:{ChangedSetting(setting=SettingCodes.MAX_CONCURRENT_STREAMS, original_value=None, new_value=100), ChangedSetting(setting=SettingCodes.INITIAL_WINDOW_SIZE, original_value=65535, new_value=1048576), ChangedSetting(setting=SettingCodes.MAX_HEADER_LIST_SIZE, original_value=None, new_value=16384)}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<WindowUpdated stream_id:0, delta:983041> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<SettingsAcknowledged changed_settings:{}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<ResponseReceived stream_id:1, headers:[(b':status', b'200'), (b'date', b'Wed, 06 Nov 2019 18:18:56 GMT'), (b'expires', b'-1'), (b'cache-control', b'private, max-age=0'), (b'content-type', b'text/html; charset=ISO-8859-1'), (b'p3p', b'CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\"'), (b'content-encoding', b'gzip'), (b'server', b'gws'), (b'content-length', b'5073'), (b'x-xss-protection', b'0'), (b'x-frame-options', b'SAMEORIGIN'), (b'set-cookie', b'1P_JAR=2019-11-06-18; expires=Fri, 06-Dec-2019 18:18:56 GMT; path=/; domain=.google.com; SameSite=none'), (b'set-cookie', b'NID=190=m8G9qLxCz2_4HbZI02ON2HTJF4xTvOhoJiS57Hm-OJrNS2eY20LfXMR_u-mLjujeshW5-BTezI69OGpHksT4ZK2TCDsWeU0DF7AmDTjjXFOdj30eIUTpNq7r9aWRvI8UrqiwlIsLkE8Ee3t5PiIiVdSMUcji7dkavGlMUpkMXU8; expires=Thu, 07-May-2020 18:18:56 GMT; path=/; domain=.google.com; HttpOnly'), (b'alt-svc', b'quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q050=\":443\"; ma=2592000,h3-Q049=\":443\"; ma=2592000,h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000')]> DEBUG [2019-11-06 19:18:56] httpx.client - HTTP Request: GET https://www.google.com/ \"HTTP/2 200 OK\" TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<DataReceived stream_id:1, flow_controlled_length:5186, data:1f8b08000000000002ffc55af97adb4692ff3f4f> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<DataReceived stream_id:1, flow_controlled_length:221, data:> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<StreamEnded stream_id:1> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<PingReceived ping_data:0000000000000000> TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - release_connection connection=HTTPConnection(origin=Origin(scheme='https' host='www.google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - close_connection SSLKEYLOGFILE Valid values: a filename If this environment variable is set, TLS keys will be appended to the specified file, creating it if it doesn't exist, whenever key material is generated or received. The keylog file is designed for debugging purposes only. Support for SSLKEYLOGFILE requires Python 3.8 and OpenSSL 1.1.1 or newer. Example: # test_script.py import httpx with httpx . Client () as client : r = client . get ( \"https://google.com\" ) SSLKEYLOGFILE=test.log python test_script.py cat test.log # TLS secrets log file, generated by OpenSSL / Python SERVER_HANDSHAKE_TRAFFIC_SECRET XXXX EXPORTER_SECRET XXXX SERVER_TRAFFIC_SECRET_0 XXXX CLIENT_HANDSHAKE_TRAFFIC_SECRET XXXX CLIENT_TRAFFIC_SECRET_0 XXXX SERVER_HANDSHAKE_TRAFFIC_SECRET XXXX EXPORTER_SECRET XXXX SERVER_TRAFFIC_SECRET_0 XXXX CLIENT_HANDSHAKE_TRAFFIC_SECRET XXXX CLIENT_TRAFFIC_SECRET_0 XXXX SSL_CERT_FILE Valid values: a filename if this environment variable is set then HTTPX will load CA certificate from the specified file instead of the default location. Example: SSL_CERT_FILE=/path/to/ca-certs/ca-bundle.crt python -c \"import httpx; httpx.get('https://example.com')\" SSL_CERT_DIR Valid values: a directory if this environment variable is set then HTTPX will load CA certificates from the specified location instead of the default location. Example: SSL_CERT_DIR=/path/to/ca-certs/ python -c \"import httpx; httpx.get('https://example.com')\" HTTP_PROXY , HTTPS_PROXY , ALL_PROXY Valid values: A URL to a proxy Sets the proxy to be used for http , https , or all requests respectively. export HTTP_PROXY = http://127.0.0.1:3080 # This request will be sent through the proxy python -c \"import httpx; httpx.get('http://example.com')\"","title":"Environment Variables"},{"location":"environment_variables/#environment-variables","text":"The HTTPX library can be configured via environment variables. Environment variables are used by default. To ignore environment variables, trust_env has to be set False . There are two ways to set trust_env to disable environment variables: On the client via httpx.Client(trust_env=False) Per request via client.get(\"<url>\", trust_env=False) Here is a list of environment variables that HTTPX recognizes and what function they serve:","title":"Environment Variables"},{"location":"environment_variables/#httpx_log_level","text":"Valid values: debug , trace (case-insensitive) If set to debug , then HTTP requests will be logged to stderr . This is useful for general purpose reporting of network activity. If set to trace , then low-level details about the execution of HTTP requests will be logged to stderr , in addition to debug log lines. This can help you debug issues and see what's exactly being sent over the wire and to which location. Example: # test_script.py import httpx with httpx . Client () as client : r = client . get ( \"https://google.com\" ) Debug output: $ HTTPX_LOG_LEVEL = debug python test_script.py DEBUG [2019-11-06 19:11:24] httpx.client - HTTP Request: GET https://google.com \"HTTP/1.1 301 Moved Permanently\" DEBUG [2019-11-06 19:11:24] httpx.client - HTTP Request: GET https://www.google.com/ \"HTTP/1.1 200 OK\" Trace output: $ HTTPX_LOG_LEVEL = trace python test_script.py TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - acquire_connection origin=Origin(scheme='https' host='google.com' port=443) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - new_connection connection=HTTPConnection(origin=Origin(scheme='https' host='google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.config - load_ssl_context verify=True cert=None trust_env=True http_versions=HTTPVersionConfig(['HTTP/1.1', 'HTTP/2']) TRACE [2019-11-06 19:18:56] httpx.config - load_verify_locations cafile=/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/certifi/cacert.pem TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - start_connect host='google.com' port=443 timeout=TimeoutConfig(timeout=5.0) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - connected http_version='HTTP/2' TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - send_headers stream_id=1 method='GET' target='/' headers=[(b':method', b'GET'), (b':authority', b'google.com'), (b':scheme', b'https'), (b':path', b'/'), (b'user-agent', b'python-httpx/0.7.6'), (b'accept', b'*/*'), (b'accept-encoding', b'gzip, deflate, br'), (b'connection', b'keep-alive')] TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - end_stream stream_id=1 TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<RemoteSettingsChanged changed_settings:{ChangedSetting(setting=SettingCodes.MAX_CONCURRENT_STREAMS, original_value=None, new_value=100), ChangedSetting(setting=SettingCodes.INITIAL_WINDOW_SIZE, original_value=65535, new_value=1048576), ChangedSetting(setting=SettingCodes.MAX_HEADER_LIST_SIZE, original_value=None, new_value=16384)}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<WindowUpdated stream_id:0, delta:983041> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<SettingsAcknowledged changed_settings:{}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<ResponseReceived stream_id:1, headers:[(b':status', b'301'), (b'location', b'https://www.google.com/'), (b'content-type', b'text/html; charset=UTF-8'), (b'date', b'Wed, 06 Nov 2019 18:18:56 GMT'), (b'expires', b'Fri, 06 Dec 2019 18:18:56 GMT'), (b'cache-control', b'public, max-age=2592000'), (b'server', b'gws'), (b'content-length', b'220'), (b'x-xss-protection', b'0'), (b'x-frame-options', b'SAMEORIGIN'), (b'alt-svc', b'quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q050=\":443\"; ma=2592000,h3-Q049=\":443\"; ma=2592000,h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000')]> DEBUG [2019-11-06 19:18:56] httpx.client - HTTP Request: GET https://google.com \"HTTP/2 301 Moved Permanently\" TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - acquire_connection origin=Origin(scheme='https' host='www.google.com' port=443) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - new_connection connection=HTTPConnection(origin=Origin(scheme='https' host='www.google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.config - load_ssl_context verify=True cert=None trust_env=True http_versions=HTTPVersionConfig(['HTTP/1.1', 'HTTP/2']) TRACE [2019-11-06 19:18:56] httpx.config - load_verify_locations cafile=/Users/florimond/Developer/python-projects/httpx/venv/lib/python3.8/site-packages/certifi/cacert.pem TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - start_connect host='www.google.com' port=443 timeout=TimeoutConfig(timeout=5.0) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - connected http_version='HTTP/2' TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - send_headers stream_id=1 method='GET' target='/' headers=[(b':method', b'GET'), (b':authority', b'www.google.com'), (b':scheme', b'https'), (b':path', b'/'), (b'user-agent', b'python-httpx/0.7.6'), (b'accept', b'*/*'), (b'accept-encoding', b'gzip, deflate, br'), (b'connection', b'keep-alive')] TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - end_stream stream_id=1 TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<RemoteSettingsChanged changed_settings:{ChangedSetting(setting=SettingCodes.MAX_CONCURRENT_STREAMS, original_value=None, new_value=100), ChangedSetting(setting=SettingCodes.INITIAL_WINDOW_SIZE, original_value=65535, new_value=1048576), ChangedSetting(setting=SettingCodes.MAX_HEADER_LIST_SIZE, original_value=None, new_value=16384)}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<WindowUpdated stream_id:0, delta:983041> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<SettingsAcknowledged changed_settings:{}> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<ResponseReceived stream_id:1, headers:[(b':status', b'200'), (b'date', b'Wed, 06 Nov 2019 18:18:56 GMT'), (b'expires', b'-1'), (b'cache-control', b'private, max-age=0'), (b'content-type', b'text/html; charset=ISO-8859-1'), (b'p3p', b'CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\"'), (b'content-encoding', b'gzip'), (b'server', b'gws'), (b'content-length', b'5073'), (b'x-xss-protection', b'0'), (b'x-frame-options', b'SAMEORIGIN'), (b'set-cookie', b'1P_JAR=2019-11-06-18; expires=Fri, 06-Dec-2019 18:18:56 GMT; path=/; domain=.google.com; SameSite=none'), (b'set-cookie', b'NID=190=m8G9qLxCz2_4HbZI02ON2HTJF4xTvOhoJiS57Hm-OJrNS2eY20LfXMR_u-mLjujeshW5-BTezI69OGpHksT4ZK2TCDsWeU0DF7AmDTjjXFOdj30eIUTpNq7r9aWRvI8UrqiwlIsLkE8Ee3t5PiIiVdSMUcji7dkavGlMUpkMXU8; expires=Thu, 07-May-2020 18:18:56 GMT; path=/; domain=.google.com; HttpOnly'), (b'alt-svc', b'quic=\":443\"; ma=2592000; v=\"46,43\",h3-Q050=\":443\"; ma=2592000,h3-Q049=\":443\"; ma=2592000,h3-Q048=\":443\"; ma=2592000,h3-Q046=\":443\"; ma=2592000,h3-Q043=\":443\"; ma=2592000')]> DEBUG [2019-11-06 19:18:56] httpx.client - HTTP Request: GET https://www.google.com/ \"HTTP/2 200 OK\" TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<DataReceived stream_id:1, flow_controlled_length:5186, data:1f8b08000000000002ffc55af97adb4692ff3f4f> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<DataReceived stream_id:1, flow_controlled_length:221, data:> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=1 event=<StreamEnded stream_id:1> TRACE [2019-11-06 19:18:56] httpx.dispatch.http2 - receive_event stream_id=0 event=<PingReceived ping_data:0000000000000000> TRACE [2019-11-06 19:18:56] httpx.dispatch.connection_pool - release_connection connection=HTTPConnection(origin=Origin(scheme='https' host='www.google.com' port=443)) TRACE [2019-11-06 19:18:56] httpx.dispatch.connection - close_connection","title":"HTTPX_LOG_LEVEL"},{"location":"environment_variables/#sslkeylogfile","text":"Valid values: a filename If this environment variable is set, TLS keys will be appended to the specified file, creating it if it doesn't exist, whenever key material is generated or received. The keylog file is designed for debugging purposes only. Support for SSLKEYLOGFILE requires Python 3.8 and OpenSSL 1.1.1 or newer. Example: # test_script.py import httpx with httpx . Client () as client : r = client . get ( \"https://google.com\" ) SSLKEYLOGFILE=test.log python test_script.py cat test.log # TLS secrets log file, generated by OpenSSL / Python SERVER_HANDSHAKE_TRAFFIC_SECRET XXXX EXPORTER_SECRET XXXX SERVER_TRAFFIC_SECRET_0 XXXX CLIENT_HANDSHAKE_TRAFFIC_SECRET XXXX CLIENT_TRAFFIC_SECRET_0 XXXX SERVER_HANDSHAKE_TRAFFIC_SECRET XXXX EXPORTER_SECRET XXXX SERVER_TRAFFIC_SECRET_0 XXXX CLIENT_HANDSHAKE_TRAFFIC_SECRET XXXX CLIENT_TRAFFIC_SECRET_0 XXXX","title":"SSLKEYLOGFILE"},{"location":"environment_variables/#ssl_cert_file","text":"Valid values: a filename if this environment variable is set then HTTPX will load CA certificate from the specified file instead of the default location. Example: SSL_CERT_FILE=/path/to/ca-certs/ca-bundle.crt python -c \"import httpx; httpx.get('https://example.com')\"","title":"SSL_CERT_FILE"},{"location":"environment_variables/#ssl_cert_dir","text":"Valid values: a directory if this environment variable is set then HTTPX will load CA certificates from the specified location instead of the default location. Example: SSL_CERT_DIR=/path/to/ca-certs/ python -c \"import httpx; httpx.get('https://example.com')\"","title":"SSL_CERT_DIR"},{"location":"environment_variables/#http_proxy-https_proxy-all_proxy","text":"Valid values: A URL to a proxy Sets the proxy to be used for http , https , or all requests respectively. export HTTP_PROXY = http://127.0.0.1:3080 # This request will be sent through the proxy python -c \"import httpx; httpx.get('http://example.com')\"","title":"HTTP_PROXY, HTTPS_PROXY, ALL_PROXY"},{"location":"quickstart/","text":"QuickStart Note The standard Python REPL does not allow top-level async statements. To run async examples directly you'll probably want to either use ipython , or use Python 3.8 with python -m asyncio . First, start by importing HTTPX: >>> import httpx Now, let\u2019s try to get a webpage. >>> r = await httpx . get ( 'https://httpbin.org/get' ) >>> r < Response [ 200 OK ] > Similarly, to make an HTTP POST request: >>> r = await httpx . post ( 'https://httpbin.org/post' , data = { 'key' : 'value' }) The PUT, DELETE, HEAD, and OPTIONS requests all follow the same style: >>> r = await httpx . put ( 'https://httpbin.org/put' , data = { 'key' : 'value' }) >>> r = await httpx . delete ( 'https://httpbin.org/delete' ) >>> r = await httpx . head ( 'https://httpbin.org/get' ) >>> r = await httpx . options ( 'https://httpbin.org/get' ) Passing Parameters in URLs To include URL query parameters in the request, use the params keyword: >>> params = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = await httpx . get ( 'https://httpbin.org/get' , params = params ) To see how the values get encoding into the URL string, we can inspect the resulting URL that was used to make the request: >>> r . url URL ( 'https://httpbin.org/get?key2=value2&key1=value1' ) You can also pass a list of items as a value: >>> params = { 'key1' : 'value1' , 'key2' : [ 'value2' , 'value3' ]} >>> r = await httpx . get ( 'https://httpbin.org/get' , params = params ) >>> r . url URL ( 'https://httpbin.org/get?key1=value1&key2=value2&key2=value3' ) Response Content HTTPX will automatically handle decoding the response content into Unicode text. >>> r = await httpx . get ( 'https://www.example.org/' ) >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' You can inspect what encoding has been used to decode the response. >>> r . encoding 'UTF-8' If you need to override the standard behavior and explicitly set the encoding to use, then you can do that too. >>> r . encoding = 'ISO-8859-1' Binary Response Content The response content can also be accessed as bytes, for non-text responses: >>> r . content b '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Any gzip and deflate HTTP response encodings will automatically be decoded for you. If brotlipy is installed, then the brotli response encoding will also be supported. For example, to create an image from binary data returned by a request, you can use the following code: >>> from PIL import Image >>> from io import BytesIO >>> i = Image . open ( BytesIO ( r . content )) JSON Response Content Often Web API responses will be encoded as JSON. >>> r = await httpx . get ( 'https://api.github.com/events' ) >>> r . json () [{ u 'repository' : { u 'open_issues' : 0 , u 'url' : 'https://github.com/...' ... }}] Custom Headers To include additional headers in the outgoing request, use the headers keyword argument: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> r = await httpx . get ( url , headers = headers ) Sending Form Encoded Data Some types of HTTP requests, such as POST and PUT requests, can include data in the request body. One common way of including that is as form-encoded data, which is used for HTML forms. >>> data = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = await httpx . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key2\" : \"value2\" , \"key1\" : \"value1\" }, ... } Form encoded data can also include multiple values form a given key. >>> data = { 'key1' : [ 'value1' , 'value2' ]} >>> r = await httpx . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key1\" : [ \"value1\" , \"value2\" ] }, ... } Sending Multipart File Uploads You can also upload files, using HTTP multipart encoding: >>> files = { 'upload-file' : open ( 'report.xls' , 'rb' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... } You can also explicitly set the filename and content type, by using a tuple of items for the file value: >>> files = { 'upload-file' : ( 'report.xls' , open ( 'report.xls' , 'rb' ), 'application/vnd.ms-excel' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... } Sending JSON Encoded Data Form encoded data is okay if all you need is a simple key-value data structure. For more complicated data structures you'll often want to use JSON encoding instead. >>> data = { 'integer' : 123 , 'boolean' : True , 'list' : [ 'a' , 'b' , 'c' ]} >>> r = await httpx . post ( \"https://httpbin.org/post\" , json = data ) >>> print ( r . text ) { ... \"json\" : { \"boolean\" : true , \"integer\" : 123 , \"list\" : [ \"a\" , \"b\" , \"c\" ] }, ... } Sending Binary Request Data For other encodings, you should use either a bytes type or a generator that yields bytes . You'll probably also want to set a custom Content-Type header when uploading binary data. Response Status Codes We can inspect the HTTP status code of the response: >>> r = await httpx . get ( 'https://httpbin.org/get' ) >>> r . status_code 200 HTTPX also includes an easy shortcut for accessing status codes by their text phrase. >>> r . status_code == httpx . codes . OK True We can raise an exception for any Client or Server error responses (4xx or 5xx status codes): >>> not_found = await httpx . get ( 'https://httpbin.org/status/404' ) >>> not_found . status_code 404 >>> not_found . raise_for_status () Traceback ( most recent call last ): File \"/Users/tomchristie/GitHub/encode/httpcore/httpx/models.py\" , line 776 , in raise_for_status raise HttpError ( message ) httpx . exceptions . HttpError : 404 Not Found Any successful response codes will simply return None rather than raising an exception. >>> r . raise_for_status () Response Headers The response headers are available as a dictionary-like interface. >>> r . headers Headers ({ 'content-encoding' : 'gzip' , 'transfer-encoding' : 'chunked' , 'connection' : 'close' , 'server' : 'nginx/1.0.4' , 'x-runtime' : '148ms' , 'etag' : '\"e1ca502697e5c9317743dc078f67693f\"' , 'content-type' : 'application/json' }) The Headers data type is case-insensitive, so you can use any capitalization. >>> r . headers [ 'Content-Type' ] 'application/json' >>> r . headers . get ( 'content-type' ) 'application/json' Multiple values for a single response header are represented as a single comma-separated value, as per RFC 7230 : A recipient MAY combine multiple header fields with the same field name into one \u201cfield-name: field-value\u201d pair, without changing the semantics of the message, by appending each subsequent field-value to the combined field value in order, separated by a comma. Cookies Any cookies that are set on the response can be easily accessed: >>> r = await httpx . get ( 'http://httpbin.org/cookies/set?chocolate=chip' , allow_redirects = False ) >>> r . cookies [ 'chocolate' ] 'chip' To include cookies in an outgoing request, use the cookies parameter: >>> cookies = { \"peanut\" : \"butter\" } >>> r = await httpx . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'peanut' : 'butter' }} Cookies are returned in a Cookies instance, which is a dict-like data structure with additional API for accessing cookies by their domain or path. >>> cookies = httpx . Cookies () >>> cookies . set ( 'cookie_on_domain' , 'hello, there!' , domain = 'httpbin.org' ) >>> cookies . set ( 'cookie_off_domain' , 'nope.' , domain = 'example.org' ) >>> r = await httpx . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'cookie_on_domain' : 'hello, there!' }} Redirection and History By default, HTTPX will follow redirects for anything except HEAD requests. The history property of the response can be used to inspect any followed redirects. It contains a list of all any redirect responses that were followed, in the order in which they were made. For example, GitHub redirects all HTTP requests to HTTPS. >>> r = await httpx . get ( 'http://github.com/' ) >>> r . url URL ( 'https://github.com/' ) >>> r . status_code 200 >>> r . history [ < Response [ 301 Moved Permanently ] > ] You can modify the default redirection handling with the allow_redirects parameter: >>> r = await httpx . get ( 'http://github.com/' , allow_redirects = False ) >>> r . status_code 301 >>> r . history [] If you\u2019re making a HEAD request, you can use this to enable redirection: >>> r = await httpx . head ( 'http://github.com/' , allow_redirects = True ) >>> r . url 'https://github.com/' >>> r . history [ < Response [ 301 Moved Permanently ] > ] Timeouts HTTPX defaults to including reasonable timeouts for all network operations, meaning that if a connection is not properly established then it should always raise an error rather than hanging indefinitely. The default timeout for network inactivity is five seconds. You can modify the value to be more or less strict: >>> await httpx . get ( 'https://github.com/' , timeout = 0.001 ) For advanced timeout management, see Timeout fine-tuning . Authentication HTTPX supports Basic and Digest HTTP authentication. To provide Basic authentication credentials, pass a 2-tuple of plaintext str or bytes objects as the auth argument to the request functions: >>> await httpx . get ( \"https://example.com\" , auth = ( \"my_user\" , \"password123\" )) To provide credentials for Digest authentication you'll need to instantiate a DigestAuth object with the plaintext username and password as arguments. This object can be then passed as the auth argument to the request methods as above: >>> auth = httpx . DigestAuth ( \"my_user\" , \"password123\" ) >>> await httpx . get ( \"https://example.com\" , auth = auth ) < Response [ 200 OK ] >","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"Note The standard Python REPL does not allow top-level async statements. To run async examples directly you'll probably want to either use ipython , or use Python 3.8 with python -m asyncio . First, start by importing HTTPX: >>> import httpx Now, let\u2019s try to get a webpage. >>> r = await httpx . get ( 'https://httpbin.org/get' ) >>> r < Response [ 200 OK ] > Similarly, to make an HTTP POST request: >>> r = await httpx . post ( 'https://httpbin.org/post' , data = { 'key' : 'value' }) The PUT, DELETE, HEAD, and OPTIONS requests all follow the same style: >>> r = await httpx . put ( 'https://httpbin.org/put' , data = { 'key' : 'value' }) >>> r = await httpx . delete ( 'https://httpbin.org/delete' ) >>> r = await httpx . head ( 'https://httpbin.org/get' ) >>> r = await httpx . options ( 'https://httpbin.org/get' )","title":"QuickStart"},{"location":"quickstart/#passing-parameters-in-urls","text":"To include URL query parameters in the request, use the params keyword: >>> params = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = await httpx . get ( 'https://httpbin.org/get' , params = params ) To see how the values get encoding into the URL string, we can inspect the resulting URL that was used to make the request: >>> r . url URL ( 'https://httpbin.org/get?key2=value2&key1=value1' ) You can also pass a list of items as a value: >>> params = { 'key1' : 'value1' , 'key2' : [ 'value2' , 'value3' ]} >>> r = await httpx . get ( 'https://httpbin.org/get' , params = params ) >>> r . url URL ( 'https://httpbin.org/get?key1=value1&key2=value2&key2=value3' )","title":"Passing Parameters in URLs"},{"location":"quickstart/#response-content","text":"HTTPX will automatically handle decoding the response content into Unicode text. >>> r = await httpx . get ( 'https://www.example.org/' ) >>> r . text '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' You can inspect what encoding has been used to decode the response. >>> r . encoding 'UTF-8' If you need to override the standard behavior and explicitly set the encoding to use, then you can do that too. >>> r . encoding = 'ISO-8859-1'","title":"Response Content"},{"location":"quickstart/#binary-response-content","text":"The response content can also be accessed as bytes, for non-text responses: >>> r . content b '<!doctype html> \\n <html> \\n <head> \\n <title>Example Domain</title>...' Any gzip and deflate HTTP response encodings will automatically be decoded for you. If brotlipy is installed, then the brotli response encoding will also be supported. For example, to create an image from binary data returned by a request, you can use the following code: >>> from PIL import Image >>> from io import BytesIO >>> i = Image . open ( BytesIO ( r . content ))","title":"Binary Response Content"},{"location":"quickstart/#json-response-content","text":"Often Web API responses will be encoded as JSON. >>> r = await httpx . get ( 'https://api.github.com/events' ) >>> r . json () [{ u 'repository' : { u 'open_issues' : 0 , u 'url' : 'https://github.com/...' ... }}]","title":"JSON Response Content"},{"location":"quickstart/#custom-headers","text":"To include additional headers in the outgoing request, use the headers keyword argument: >>> url = 'http://httpbin.org/headers' >>> headers = { 'user-agent' : 'my-app/0.0.1' } >>> r = await httpx . get ( url , headers = headers )","title":"Custom Headers"},{"location":"quickstart/#sending-form-encoded-data","text":"Some types of HTTP requests, such as POST and PUT requests, can include data in the request body. One common way of including that is as form-encoded data, which is used for HTML forms. >>> data = { 'key1' : 'value1' , 'key2' : 'value2' } >>> r = await httpx . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key2\" : \"value2\" , \"key1\" : \"value1\" }, ... } Form encoded data can also include multiple values form a given key. >>> data = { 'key1' : [ 'value1' , 'value2' ]} >>> r = await httpx . post ( \"https://httpbin.org/post\" , data = data ) >>> print ( r . text ) { ... \"form\" : { \"key1\" : [ \"value1\" , \"value2\" ] }, ... }","title":"Sending Form Encoded Data"},{"location":"quickstart/#sending-multipart-file-uploads","text":"You can also upload files, using HTTP multipart encoding: >>> files = { 'upload-file' : open ( 'report.xls' , 'rb' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... } You can also explicitly set the filename and content type, by using a tuple of items for the file value: >>> files = { 'upload-file' : ( 'report.xls' , open ( 'report.xls' , 'rb' ), 'application/vnd.ms-excel' )} >>> r = await httpx . post ( \"https://httpbin.org/post\" , files = files ) >>> print ( r . text ) { ... \"files\" : { \"upload-file\" : \"<... binary content ...>\" }, ... }","title":"Sending Multipart File Uploads"},{"location":"quickstart/#sending-json-encoded-data","text":"Form encoded data is okay if all you need is a simple key-value data structure. For more complicated data structures you'll often want to use JSON encoding instead. >>> data = { 'integer' : 123 , 'boolean' : True , 'list' : [ 'a' , 'b' , 'c' ]} >>> r = await httpx . post ( \"https://httpbin.org/post\" , json = data ) >>> print ( r . text ) { ... \"json\" : { \"boolean\" : true , \"integer\" : 123 , \"list\" : [ \"a\" , \"b\" , \"c\" ] }, ... }","title":"Sending JSON Encoded Data"},{"location":"quickstart/#sending-binary-request-data","text":"For other encodings, you should use either a bytes type or a generator that yields bytes . You'll probably also want to set a custom Content-Type header when uploading binary data.","title":"Sending Binary Request Data"},{"location":"quickstart/#response-status-codes","text":"We can inspect the HTTP status code of the response: >>> r = await httpx . get ( 'https://httpbin.org/get' ) >>> r . status_code 200 HTTPX also includes an easy shortcut for accessing status codes by their text phrase. >>> r . status_code == httpx . codes . OK True We can raise an exception for any Client or Server error responses (4xx or 5xx status codes): >>> not_found = await httpx . get ( 'https://httpbin.org/status/404' ) >>> not_found . status_code 404 >>> not_found . raise_for_status () Traceback ( most recent call last ): File \"/Users/tomchristie/GitHub/encode/httpcore/httpx/models.py\" , line 776 , in raise_for_status raise HttpError ( message ) httpx . exceptions . HttpError : 404 Not Found Any successful response codes will simply return None rather than raising an exception. >>> r . raise_for_status ()","title":"Response Status Codes"},{"location":"quickstart/#response-headers","text":"The response headers are available as a dictionary-like interface. >>> r . headers Headers ({ 'content-encoding' : 'gzip' , 'transfer-encoding' : 'chunked' , 'connection' : 'close' , 'server' : 'nginx/1.0.4' , 'x-runtime' : '148ms' , 'etag' : '\"e1ca502697e5c9317743dc078f67693f\"' , 'content-type' : 'application/json' }) The Headers data type is case-insensitive, so you can use any capitalization. >>> r . headers [ 'Content-Type' ] 'application/json' >>> r . headers . get ( 'content-type' ) 'application/json' Multiple values for a single response header are represented as a single comma-separated value, as per RFC 7230 : A recipient MAY combine multiple header fields with the same field name into one \u201cfield-name: field-value\u201d pair, without changing the semantics of the message, by appending each subsequent field-value to the combined field value in order, separated by a comma.","title":"Response Headers"},{"location":"quickstart/#cookies","text":"Any cookies that are set on the response can be easily accessed: >>> r = await httpx . get ( 'http://httpbin.org/cookies/set?chocolate=chip' , allow_redirects = False ) >>> r . cookies [ 'chocolate' ] 'chip' To include cookies in an outgoing request, use the cookies parameter: >>> cookies = { \"peanut\" : \"butter\" } >>> r = await httpx . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'peanut' : 'butter' }} Cookies are returned in a Cookies instance, which is a dict-like data structure with additional API for accessing cookies by their domain or path. >>> cookies = httpx . Cookies () >>> cookies . set ( 'cookie_on_domain' , 'hello, there!' , domain = 'httpbin.org' ) >>> cookies . set ( 'cookie_off_domain' , 'nope.' , domain = 'example.org' ) >>> r = await httpx . get ( 'http://httpbin.org/cookies' , cookies = cookies ) >>> r . json () { 'cookies' : { 'cookie_on_domain' : 'hello, there!' }}","title":"Cookies"},{"location":"quickstart/#redirection-and-history","text":"By default, HTTPX will follow redirects for anything except HEAD requests. The history property of the response can be used to inspect any followed redirects. It contains a list of all any redirect responses that were followed, in the order in which they were made. For example, GitHub redirects all HTTP requests to HTTPS. >>> r = await httpx . get ( 'http://github.com/' ) >>> r . url URL ( 'https://github.com/' ) >>> r . status_code 200 >>> r . history [ < Response [ 301 Moved Permanently ] > ] You can modify the default redirection handling with the allow_redirects parameter: >>> r = await httpx . get ( 'http://github.com/' , allow_redirects = False ) >>> r . status_code 301 >>> r . history [] If you\u2019re making a HEAD request, you can use this to enable redirection: >>> r = await httpx . head ( 'http://github.com/' , allow_redirects = True ) >>> r . url 'https://github.com/' >>> r . history [ < Response [ 301 Moved Permanently ] > ]","title":"Redirection and History"},{"location":"quickstart/#timeouts","text":"HTTPX defaults to including reasonable timeouts for all network operations, meaning that if a connection is not properly established then it should always raise an error rather than hanging indefinitely. The default timeout for network inactivity is five seconds. You can modify the value to be more or less strict: >>> await httpx . get ( 'https://github.com/' , timeout = 0.001 ) For advanced timeout management, see Timeout fine-tuning .","title":"Timeouts"},{"location":"quickstart/#authentication","text":"HTTPX supports Basic and Digest HTTP authentication. To provide Basic authentication credentials, pass a 2-tuple of plaintext str or bytes objects as the auth argument to the request functions: >>> await httpx . get ( \"https://example.com\" , auth = ( \"my_user\" , \"password123\" )) To provide credentials for Digest authentication you'll need to instantiate a DigestAuth object with the plaintext username and password as arguments. This object can be then passed as the auth argument to the request methods as above: >>> auth = httpx . DigestAuth ( \"my_user\" , \"password123\" ) >>> await httpx . get ( \"https://example.com\" , auth = auth ) < Response [ 200 OK ] >","title":"Authentication"}]}